<!DOCTYPE html>
<!--Credit to vexcess for pjs in html -->
<html>

<head>
	<meta charset="utf-8">
	<title>just trying out pjs in html</title>
	<style>
		body {
			/*gets ride of scroll bars*/
			overflow: hidden;
			/*makes the canvas flush with the edge of the screen*/
			margin: 0%;

			
			font-size: 30px;

			background-color: white;

			text-align: center;
		}
	</style>
</head>

<body>
	<script id="PJS_code" type="data" data-width="600" data-height="600">
	
		console.clear();
		
	


// WASD to move, space to attack, numbers for weapons

// change for different controls
var keyBinds = {
    upDir:87,
    leftDir:65,
    downDir:83,
    rightDir:68,
    weapons:[49,50,51,52,53,54],
    autopilot:79,
    //powers:[90,88,67,86,66,78,77],
    togglePowerUp:81,
    togglePowerDown:69,
    
    
    attack:32,
    usePower:"click",
    
};


// Decrease if loading crashes your computer
var loadRep = 10;

// increase if pathfinding crashes the game
var pathfindingInt = 100;



var scene = 'loading';
var getActualMouse;
var standardAiOff = 17;

var weapons = [
    ['iron sword',
    {
    anim: 'thrust',
    damage: 30,
    cooldown: 30,
    reach: 43,
    sweep: 30,
    knockback: 8.5,
    abilities: [],
    swingDuration: 0,
    aiDist: 43 + standardAiOff,
    hbDis: {x:14,y:558,rot:-15},
    }],
    ['iron greatsword',
    {
    anim: 'sweep',
    damage: 30,
    cooldown: 120,
    reach: 150,
    sweep: 90,
    knockback: 15,
    abilities: [],
    slow: 0.7,
    delay: [30,0.25],
    swingDuration: 5,
    swingMod:-90,
    invert:true,
    aiDist: 150 + standardAiOff,
    hbDis: {x:20,y:570,rot:-107,scale:0.35},
    textDis: {x:0,y:-4},
    }],
    ['iron dagger',
    {
    anim: 'sweep',
    damage: 20,
    cooldown: 70,
    reach: 33,
    sweep: 0,
    sweepMod: 30,
    knockback: 5,
    swingStill: true,
    abilities: ['dart','stun 1','continuous'],
    swingDuration: 1,
    aiDist: 133+standardAiOff,
    idealDist:133,
    hbDis: {x:14,y:558,rot:-15},
    }],
    ['geist dagger',
    {
    anim: 'sweep',
    damage: 20,
    cooldown: 70,
    reach: 33,
    sweep: 0,
    sweepMod: 30,
    knockback: 5,
    abilities: ['dart','geist'],
    swingDuration: 1,
    aiDist: 133+standardAiOff,
    hbDis: {x:14,y:558,rot:-15},
    }],
    ['iron spear',
    {
    anim: 'thrust',
    damage: 30,
    cooldown: 50,
    reach: 98,
    sweep: 14,
    knockback:7,
    abilities: [],
    swingDuration: 0,
    aiDist: 98+standardAiOff,
    idealDist: 60,
    hbDis: {x:-3,y:563,rot:-15,scale:0.8},
    }],
    ['iron axe',
    {
    anim: 'sweep',
    damage: 30,
    cooldown: 80,
    reach: 68,
    sweep: 90,
    knockback:11,
    abilities: [ ],
    delay: [10,0.3],
    swingDuration: 10,
    swingMod:90,
    aiDist: 60+standardAiOff,
    hbDis: {x:30,y:573,rot:40,scale:0.7},
    }],
    ['heavy axe',
    {
    anim: 'sweep',
    damage: 30,
    cooldown: 120,
    reach: 68,
    sweep: 360,
    knockback:15,
    abilities: ['fling'],
    delay: [40,0.25],
    swingDuration: 35,
    swingMod:90,
    aiDist: 168+standardAiOff,
    hbDis: {x:30,y:573,rot:40,scale:0.7},
    }],
    ['iron katana',
    {
    anim: 'sweep',
    damage: 15,
    cooldown: 60,
    reach: 60,
    sweep: 75,
    knockback: 4.5,
    swingDuration: 15,
    abilities: ['fling2'],
    aiDist: 100+standardAiOff,
    hbDis: {x:0,y:560,rot:-15},
    }],
    ['geist katana',
    {
    anim: 'sweep',
    damage: 15,
    cooldown: 70,
    reach: 60,
    sweep: 40,
    knockback: 4.5,
    swingDuration: 15,
    aiDist: 100+standardAiOff,
    abilities: ['geist','fling2'],
    hbDis: {x:0,y:560,rot:-15},
    }],
    ['wooden recurve bow',
    {
    anim: 'twang',
    altAnim: 'twang',
    damage: 30,
    cooldown: 60,
    reach: 0,
    sweep: 0,
    sweepMod:0,
    knockback: 5,
    chargeSpeed:0.5,
    windResistance:0.4,
    useSlow:0.2,
    changeRot:0.01,
    abilities: ['charge arrow','continuous'],
    swingDuration: 1,
    aiDist: 250 + standardAiOff,
    idealDist: 250,
    hbDis: {x:43,y:575,rot:-80},
    textDis: {x:0,y:-5},
    }],
    ['lazer beam',
    {
    anim: 'firebreath',
    damage: 2,
    cooldown: 100,
    reach: 0,
    sweep: 0,
    sweepMod:0,
    knockback: 0,
    useSlow:0.2,
    changeRot:0.005,
    windResistance:0,
    frequency:2,
    delay: [50,0.4],
    abilities: ['beam','continuous'],
    type: 'lazer',
    swingDuration: 1,
    aiDist: 250 + standardAiOff,
    idealDist: 250,
    hbDis: {x:42,y:583,rot:-80},
    textDis: {x:0,y:0},
    }],
    ];
var people = [
    {
    name:'ack',
    color:color(0, 255, 251),
    health:1000,
    speed:3,
    acceleration:0.2,
    size:1,
    weapons:['lazer beam','iron dagger','iron greatsword','iron spear','geist katana','wooden recurve bow',],
    powers:['dash','halt','dash','wall of flames'],
    },
    {
    name:'abram',
    color:color(255, 0, 255),
    health:100,
    speed:3.3,
    acceleration:0.05,
    size:1,
    weapons:['iron sword','iron katana','iron dagger','iron spear','heavy axe','iron axe',],
    powers:[],
    }
    ];
var p;
var effects = [];
var projs = [];
function proj(x,y,a,v,l,d){
this.x = x;
this.y = y;
this.angle = a;
this.v = v;
this.life = l;
this.data = d;
projs.push(this);
}
function effect(x,y,r,c,t,t2,tp){
this.x = x;
this.y = y;
if(r[1]){
this.w = r[0];
this.h = r[1];
}else{
this.w = r;
this.h = r;
}
this.vx = 0;
this.vy = 0;
this.color = c;
this.timer = t;
this.ty = t2;
if(tp){
this.type = tp;
}else{
this.type = 'ellipse';
}

if(dist(x,y,p.x,p.y) < 430){
effects.push(this);
}
}
//function effect(){}
effect.prototype.draw = function() {
noStroke();
this.x += this.vx;
this.y += this.vy;
fill(this.color,this.timer);
if(this.type === 'ellipse'){
ellipse(this.x,this.y,this.w,this.h);
}
if(this.type === 'solid ellipse'){
fill(this.color);
ellipse(this.x,this.y,this.w,this.h);
}
if(this.type === 'rect'){
rect(this.x,this.y,this.w,this.h);
}
textAlign(CENTER,BASELINE);
pushMatrix();
translate(this.x,this.y);
rotate(this.rot);
translate(-this.x,-this.y);
if(this.type === 'text'){
textSize(this.textSize);
text(this.text,this.x,this.y);
}
if(this.type === 'btext'){
this.rot += this.vRot;
this.vy += 0.1;
//fill(this.color);
textSize(this.textSize);
text(this.text,this.x,this.y);
}
popMatrix();
this.timer -= this.ty;
if(this.timer <= 0){
for(var i = 0; i < effects.length; i++){
if(effects[i] === this){
effects.splice(i,1);
}
}
}
};
function projGraphics(e){
switch(e){
case 'none':
break;
case 'lazer':
noStroke();
fill(143, 0, 143,100);
//ellipse(random(-3,3),random(-3,3),20,20);
rect(random(-3,3)-10,random(-3,3)-10,20,20);
break;
case 'fireball':
noStroke();
fill(255, 123, 0,100);
//ellipse(random(-3,3),random(-3,3),20,20);
for(var i = 0; i < 5; i++){
ellipse(random(-3,3),random(-3,3),20,20);
}
break;
default:
    strokeWeight(1.5);
    stroke(148, 106, 78);
    line(-10, 0, 15, 0);
    strokeWeight(2);
    stroke(184, 184, 184);
    line(13, -2, 15, 0);
    line(13, 2, 15, 0);
    stroke(255, 255, 255);
    line(-14, 0, -10, 0);
    line(-13, -2, -10, 0);
    line(-13, 2, -10, 0);
break;
}
}

function drawEffects(){
for(var i = effects.length-1; i > -1; i--){
effects[i].draw();
}
}
function choice(e) {
    return arguments[floor(random(0, arguments.length))];
}
function diff(a, b) {
    return abs(a - b);
}
function stun(e,t){
e.stun = true;
if(e.stunTimer < t){
e.stunTimer = t;
}
}
function basicProj(s){
var d = s.rot;
    var e = new proj(s.x+cos(d)*(15*s.size),s.y+sin(d)*(15*s.size),s.rot,s.charge/1.5+8,200,{
    slow:s.use.windResistance,
    noStall:false,
    rebound:false,
    shooter:s,
    data:s.use,
    });
    s.charge = 0;
}
function flame(x,y){
pushMatrix();
translate(-222+x,-260+y);
    //fill(115, 115, 115);
    //strokeWeight(3);
    beginShape();
vertex(213,255);
vertex(196,277);
vertex(211,292);
vertex(229,295);
vertex(241,285);
vertex(250,271);
vertex(248,248);
vertex(238,258);
vertex(231,251);
vertex(224,255);
vertex(217,238);
vertex(212,255);
endShape();
beginShape();
vertex(201,265);
vertex(208,278);
vertex(219,283);
vertex(232,281);
vertex(235,271);
vertex(234,211);
vertex(222,250);
vertex(214,241);
vertex(210,250);
vertex(201,245);
vertex(201,263);
endShape();
popMatrix();
}
var abilities = [
    ['geist',{
    hit:function(s,t){
    var dir = atan2(s.y-t.y,s.x-t.x);
var postPos = [s.x,s.y];
s.x = t.x;
s.y = t.y;
t.x = postPos[0];
t.y = postPos[1];
t.vx = cos(dir)*3;
t.vy = sin(dir)*3;
for(var i = 0; i < 20; i++){
var poof = new effect(s.x,s.y,random(5,15),choice(color(128, 0, 128),color(0, 0, 0)),random(0,255),random(2,5));
poof.vx = random(-1,1);
poof.vy = random(-1,1);
}
    },
    }],
    ['stun 1',{
    hit:function(s,t){
    stun(t,60);
    },
    }],
    ['continuous',{
    duringSwing:function(s){
    if(s.cooldown <= 1){
    s.cooldown = 0;
    }
    }
    }],
    ['beam',{
    duringSwing:function(s){
    if(frameCount/s.use.frequency === round(frameCount/s.use.frequency)){
    basicProj(s);
    }
    }
    }],
    ['charge arrow',{
    duringSwing:function(s){
    s.charge+=s.use.chargeSpeed;
    },
    released:function(s){
    //println('e');
    basicProj(s);
    },
    }],
    ['fling',{
    swing:function(s){
    var dir = s.rot;
    s.vx = cos(dir)*12;
    s.vy = sin(dir)*12;
    }
    }],
    ['fling2',{
    swing:function(s){
    var dir = s.rot;
    s.vx = cos(dir)*8;
    s.vy = sin(dir)*8;
    }
    }],
    ['dart',{
    swing:function(s){
    var dir = s.rot;
    s.vx = cos(dir)*10;
    s.vy = sin(dir)*10;
    },
    endSwing:function(s){
    var dir = s.rot - 180;
    s.vx = cos(dir)*8;
    s.vy = sin(dir)*8;
    }
    }],
    ];
var powers = [
    ['dash',{
    cooldown: 100,
    changeRot: 0.03,
    use:function(s){
    s.pCharge+=0.5;
    s.altSpeed = 0.5;
    },
    released:function(s){
    
    s.vx = cos(s.rot)*(s.pCharge+3.5)/1.5;
    s.vy = sin(s.rot)*(s.pCharge+3.5)/1.5;
    for(var i = 0; i < 20; i++){
var poof = new effect(s.x,s.y,random(5,15),color(0, 51, 110),random(0,255),random(2,5));
poof.vx = random(-1,1);
poof.vy = random(-1,1);
}
    },
    symbol:function(s,c,n){
    stroke(0, 0, 0);
    if(s.powerSelect === n){
    strokeWeight(8);
    }else{
    strokeWeight(5);
    }
    fill(227, 227, 227);
    var r = 0;
    if(s.powerSelect === n){
    r = s.pCharge;
    }
    var w = s.pCooldown[n];
    if(w > c){
    w = c;
    }
    var i = random(-r,r)/2;
    rotate(45+i);
    rect(-35,-35,70,70,15);
    rotate(-45+sin(frameCount)*10-i);
    fill(115, 115, 115);
    strokeWeight(3);
    beginShape();
    vertex(0,-5);
    vertex(0,-15);
    vertex(20,0);
    vertex(0,15);
    vertex(0,5);
    vertex(-20,5);
    vertex(-20,-5);
    vertex(0,-5);
    endShape();
    noStroke();
    rotate(45-sin(frameCount)*10+i*2);
    fill(0, 255, 238,100);
    rect(-35,-35,70,70,15);
    fill(217, 0, 0,50);
    rect(-35+((15-r)*(70/15))/2,-35+((15-r)*(70/15))/2,r*(70/15),r*(70/15),15);
    fill(66, 66, 66,50);
    rect(-35,-35,(c-w)*(70/c),(c-w)*(70/c),15);
    }
    }],
    ['halt',{
    cooldown: 100,
    noHold: true,
    use:function(s){
    s.vx = 0;
    s.vy = 0;
    for(var i = 0; i < 20; i++){
var poof = new effect(s.x,s.y,random(5,15),choice(color(245, 10, 10),color(66, 38, 6)),random(0,255),random(2,5));
poof.vx = random(-2,2);
poof.vy = random(-2,2);
}
    },
    released:function(s){
    
    },
    symbol:function(s,c,n){
    stroke(0, 0, 0);
    if(s.powerSelect === n){
    strokeWeight(8);
    }else{
    strokeWeight(5);
    }
    fill(227, 227, 227);
    var r = 0;
    if(s.powerSelect === n){
    r = s.pCharge;
    }
    var w = s.pCooldown[n];
    if(w > c){
    w = c;
    }
    var i = random(-r,r)/2;
    rotate(45+i);
    rect(-35,-35,70,70,15);
    rotate(-45+sin(frameCount)*10-i);
    fill(115, 115, 115);
    strokeWeight(3);
    beginShape();
    vertex(20,20);
    vertex(12,20);
    vertex(0,8);
    vertex(-12,20);
    vertex(-20,20);
    vertex(-7,0);
    vertex(-20,-20);
    vertex(-12,-20);
    vertex(0,-8);
    vertex(12,-20);
    vertex(20,-20);
    vertex(6,0);
    vertex(20,20);
    endShape();
    noStroke();
    rotate(45-sin(frameCount)*10+i*2);
    fill(255, 0, 0,100);
    rect(-35,-35,70,70,15);
    
    fill(66, 66, 66,50);
    rect(-35,-35,(c-w)*(70/c),(c-w)*(70/c),15);
    }
    }],
    ['wall of flames',{
    cooldown: 100,
    changeRot: 0.015,
    use:function(s){
    s.pCharge+=0.2;
    s.altSpeed = 0.5;
    s.onSwingRot = s.rot;
    for(var i = (-20)*((4/15)*s.pCharge); i < 20+(20)*((4/15)*s.pCharge); i+=20){
    var d = s.rot;
    var e = new effect(s.x+cos(d)*(30*s.size)+cos(d+90)*i,s.y+sin(d)*(30*s.size)+sin(d+90)*i,20,color(255, 123, 0,100),5,1,'solid ellipse');
    }
    },
    released:function(s){
    //if(s.pCharge >= 15){
    s.pCharge+=1;
    s.vx = -(cos(s.rot)*7);
    s.vy = -(sin(s.rot)*7);
    for(var i = (-20)*((4/15)*s.pCharge); i < 20+(20)*((4/15)*s.pCharge); i+=20){
    var d = s.rot;
    var e = new proj(s.x+cos(d)*(30*s.size)+cos(d+90)*i,s.y+sin(d)*(30*s.size)+sin(d+90)*i,s.rot,4,50,{
    slow:0,
    noStall:false,
    rebound:false,
    shooter:s,
    data:{
    type:'fireball',
    knockback:6,
    damage:30,
    abilities:[],
    },
    });
    }
    },
    symbol:function(s,c,n){
    stroke(0, 0, 0);
    if(s.powerSelect === n){
    strokeWeight(8);
    }else{
    strokeWeight(5);
    }
    fill(227, 227, 227);
    var r = 0;
    if(s.powerSelect === n){
    r = s.pCharge;
    }
    var w = s.pCooldown[n];
    if(w > c){
    w = c;
    }
    var i = random(-r,r)/2;
    rotate(45+i);
    rect(-35,-35,70,70,15);
    //rotate(-45+sin(frameCount)*10-i);
    pushMatrix();
    scale(0.4);
    for(var i = 0; i < 3; i++){
    fill(156, 70, 0);
    strokeWeight(5);
    flame(i*40-38,-i*20+25);
    }
    noStroke();
    popMatrix();
    //rotate(45-sin(frameCount)*10+i*2);
    fill(186, 78, 0,100);
    rect(-35,-35,70,70,15);
    
    fill(66, 66, 66,50);
    rect(-35,-35,(c-w)*(70/c),(c-w)*(70/c),15);
     fill(217, 0, 0,50);
    rect(-35+((15-r)*(70/15))/2,-35+((15-r)*(70/15))/2,r*(70/15),r*(70/15),15);
    }
    }],
    ];

var walls = [];
var players = [];
var chunks = [];
var cam = {x:0,y:0};
var trueRandom = random(0,10000);
var keyID = [];
var keyPID = [];
//var keyPPID = [];
//var waveNum = 1;
var alive = true;

/**Inputs**/
//{

const TAPPED_TIME = 1;

class Key {
    constructor () {
        this.pressed = false;
        this.tapped = false;
        //how long key will stay tapped
        this.tappedTime = TAPPED_TIME;
    };  
    
    press () {
        this.tapped = false;
        if (this.pressed === false) {    
            this.tapped = true;
            this.tappedTime = TAPPED_TIME;
        }
        this.pressed = true;
        
    };
    
    unTap () {
        this.tapped = false;
        this.tappedTime = 0;
    };
    
    get isTapped () {
        
        if (this.tapped === true) {
            
            this.tapped = false;
            this.tappedTime = 0;
            return true;
        } else {
            return false;    
        }
    };
    
    update () {
        this.tappedTime --;
    };
};

//stores key presses
let keys = {};

keyPressed = function (){
    if (!keys[keyCode]) {
        keys[keyCode] = new Key();
    }
    keys[keyCode].press();
}
keyReleased = function (){
  keys[keyCode].pressed=false;
}

const manageKeys = () => {
    

    for (let i in keys) {
        if (keys[i].tapped === true) {
            
            keys[i].update();
            if (keys[i].tappedTime <= 0) {
                keys[i].tapped = false;
            }
        }
        
    }
    
};

//whether mouse is clicked
let mc = false;

mouseClicked = () => {
	
	mc = true;

};


//}

var monospace = createFont('monospace');
var clicked = false;
var db = !true;


// Cavan P stuff
function getTriCenter(d){
var avgX = (d.x1+d.x2+d.x3)/3;
var avgY = (d.y1+d.y2+d.y3)/3;
return {x:avgX, y:avgY};
}
function getCenter(e){
var avgX = 0;
var avgY = 0;
for(var i = 0; i < e.data.length; i++){
avgX += e.data[i].x;
avgY += e.data[i].y;
}
avgX /= e.data.length;
avgY /= e.data.length;
return {
x:avgX,
y:avgY,
};
}
var triArea = function(x1, y1, x2, y2, x3, y3){
    return Math.abs((x1*(y2-y3) + x2*(y3-y1)+ x3*(y1-y2))/2);
    //Calclulate area of any triangle
};
var isInsideTri = function(x1, y1, x2, y2, x3, y3, x, y){
    x = round(x);
    y = round(y);
    var a = triArea(x1, y1, x2, y2, x3, y3);//Area of triangle ABC
    var a1 = triArea(x1, y1, x2, y2, x, y);//Area of triangle ABP
    var a2 = triArea(x1, y1, x, y, x3, y3);//Area of triangle APC
    var a3 = triArea(x, y, x2, y2, x3, y3);//Area of triangle PBC
    
    return a===a1+a2+a3;
    //return true if area 'a' is equal to the sum of the other three triangles
};
var quadArea = function(x1, y1, x2, y2, x3, y3, x4, y4){
    return triArea(x1, y1, x2, y2, x4, y4)+triArea(x2, y2, x3, y3, x4, y4);
    //Calculate area of any quadralateral
};
var insideQuad = function(x1, y1, x2, y2, x3, y3, x4, y4, x, y){
    var a = quadArea(x1, y1, x2, y2, x3, y3, x4, y4);
    var a1 = triArea(x1, y1, x2, y2, x, y);
    var a2 = triArea(x2, y2, x3, y3, x, y);
    var a3 = triArea(x3, y3, x4, y4, x, y);
    var a4 = triArea(x4, y4, x1, y1, x, y);
    
    return (a1+a2+a3+a4-a)<=0.1e-6;
};
function between(x,a,b){
if((x >= a && x <= b)||(x >= b && x <= a)){
return true;
}
}
var drawRay = function(x, y){
    noFill();
    ellipse(x, y, 9, 9);
    line(x, y, max(width, height), y);
};
var Point = function(x, y){
    return {
        x: x,
        y: y
    };
};
var onSegment = function(p, q, r){
    return  q.x <= max(p.x, r.x) && 
            q.x >= min(p.x, r.x) && 
            q.y <= max(p.y, r.y) && 
            q.y >= min(p.y, r.y);
};
var orientation = function(p, q, r){
    var v = (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
    
    if (v===0) {
        return 0;
    }
    
    return v > 0?1:2;
};
var doIntersect = function(p1, q1, p2, q2){
    var o1 = orientation(p1, q1, p2); 
    var o2 = orientation(p1, q1, q2); 
    var o3 = orientation(p2, q2, p1); 
    var o4 = orientation(p2, q2, q1);
    
    return (o1!==o2&&o3!==o4)||(o1===0&&onSegment(p1, p2, q1))||(o2 === 0&&onSegment(p1, q2, q1))||(o3===0&&onSegment(p2, p1, q2))||(o4===0&&onSegment(p2, q1, q2));
};
var isInside = function(poly, n, p){
    if (n < 3){ 
        return false; 
    } 

    var extreme = Point(10000, p.y);

    var count = 0, i = 0; 
    do { 
        var next = (i + 1) % n; 

        if (doIntersect(poly[i], poly[next], p, extreme)){ 
            if (orientation(poly[i], p, poly[next])===0){ 
                return onSegment(poly[i], p, poly[next]); 
            } 

            count++; 
        } 
        i = next; 
    } 
    while (i !== 0); 

    return count % 2 === 1;
};
function getSize(size){
return (30*size)/2;
}
function getClosest(e,s){
var dir = atan2(s.y-e.y,s.x-e.x);
return {x:e.x+cos(dir)*getSize(e.size),y:e.y+sin(dir)*getSize(e.size)};
}
// And a bit of Bob Lyon
var nearestPointOnLine = function(ax, ay, bx, by) {
    var dx = bx - ax;  /* Vector from A to B (run) */
    var dy = by - ay;  /* ... (rise) */
    var mag2 = dx*dx + dy*dy;  /* Squared distance between A and B */
    
    /* Find and return the nearest point on line AB to point P. */
    var nearest = function(px, py) {
        var a2pX = px - ax;  /* Vector from A to P */
        var a2pY = py - ay;
        var a2pDota2b = a2pX*dx + a2pY*dy;  /* AP â¦ AB */
        var t = a2pDota2b / mag2;  /* Parametric distance from A to THE point */
        var ret = {
            x: ax + dx*t,
            y: ay + dy*t 
        };
        
        if(between(ret.x,ax,bx) && between(ret.y,ay,by)){
        return ret;
        }else{
        if(ret.x > ax && ret.x > bx){
        return{
        x: ax,
        y: ay,
        };
        }else if(ret.x < ax && ret.x < bx){
        return{
        x: ax,
        y: ay,
        };
        }else if(ret.y > ay && ret.y > by){
        return{
        x: ax,
        y: ay,
        };
        }else if(ret.y < ay && ret.y < by){
        return{
        x: ax,
        y: ay,
        };
        }else{
        return{
        x: Infinity,
        y: Infinity,
        };
        }
        }
        
        
    };
    
    return nearest;
};

// loading vars
var loadCount = 0;
var toLoad = [];
var showChunkCollisions = false;

// Chunk system
var loadCap = 1;
var otherLoadCap = 15;

var chunkSize = 10;

//var otherOtherLoadCap = 19;

function getChunk(x,y){
return {
x:floor((x+100000)/chunkSize),
y:floor((y+100000)/chunkSize),
};
}

// render
function toRenderAt(x,y){

if(chunks[getChunk(x,y).y]){
if(chunks[getChunk(x,y).y][getChunk(x,y).x]){
return chunks[getChunk(x,y).y][getChunk(x,y).x];
}
}
return [];
}
// render +1 chunk radius
function allRenderAt(x,y){
var ret = [];
for(var z = -1; z < 2; z++){
for(var c = -1; c < 2; c++){
var rend = toRenderAt(x+(z*chunkSize),y+(c*chunkSize));
for(var i = 0; i < rend.length; i++){
//this.collide(rend[i]);
//println(rend[i][1].type);
ret.push(rend[i]);
}
}
}
return ret;
}
// render +player size
function fatRenderAt(x,y,pl){
var ret = [];
var wid = 1;
wid = getSize(pl.size)/chunkSize;

for(var z = -wid; z < 1+wid; z++){
for(var c = -wid; c < 1+wid; c++){
var rend = toRenderAt(x+(z*chunkSize),y+(c*chunkSize));

for(var i = 0; i < rend.length; i++){

//this.collide(rend[i]);
//println(rend[i][1].type);
ret.push(rend[i]);
}
}
}
return ret;
}
function giveChunk(x,y,e){
if(!chunks[y]){
chunks[y] = [];
}
if(!chunks[y][x]){
chunks[y][x] = [];
}
if(!chunks[y][x].includes(e)){
chunks[y][x].push(e);
}
}
var numbersBetween = function(a,b){
var ret = [];

//println(a+' , '+b);
if(a === b){
ret.push(a);
}else{
ret.push(a);
ret.push(b);
}
if(a > b){
for(var i = b; i < a; i+= 1){
ret.push(i);
}

}
if(b > a){
for(var i = a; i < b; i+= 1){

ret.push(i);

}

}
return ret;
};
//numbersBetween = DeKhan.loopDetect(numbersBetween);
function getBetween(x,y,x2,y2){
var ret = [];
//println(x+','+y+','+x2+','+y2);
for(var i = 0; i < numbersBetween(x,x2).length; i++){
for(var q = 0; q < numbersBetween(y,y2).length; q++){
ret.push({
x:numbersBetween(x,x2)[i],
y:numbersBetween(y,y2)[q],
});
}
}
return ret;
}

var startLoading = function(){
loadCount = 0;
scene = 'loading';
toLoad = [];
for(var i = 0; i < walls.length; i++){
switch(walls[i].type){
case 'polygon':
for(var q = 0; q < walls[i].data.length; q++){
toLoad.push({point:walls[i].data[q],owner:walls[i],pos:q});
}
break;
case 'circle':
toLoad.push({point:walls[i].data,owner:walls[i]});
break;
}
}
//println(toLoad[147].point.y);
};
//startLoading = DeKhan.loopDetect(startLoading);
// trashy laggy computer crashing load system
var loadChunksa = function(){
// var i = loadCount;
// var loadRewind = false;
// //println(i);
// if(!walls[i]){
// println(i);
// }
//println(walls[i]);
for(var i = 0; i < walls.length; i++){
switch(walls[i].type){
case 'polygon':
{
//     var loadAddAlt = 0;
//     var max = walls[i].data.length;
//     if(walls[i].data.length > (loadCap)+(loadCap*walls[i].loadRew)){
//     //println(walls[58].data[19]);
//     walls[i].loadRew += 1;
//     walls[i].loadRew = round(walls[i].loadRew);
//     loadRewind = true;
//     max = (loadCap*walls[i].loadRew);
//     if(max > walls[i].data.length){
//         max = walls[i].data.length;
//     }
// }else{
// loadAddAlt = 1;
// }
    //println('max: '+max);
//for(var q = 0+(loadCap*(walls[i].loadRew-1+loadAddAlt)); q < max; q++){
for(var q = 0; q < walls[i].data.length; q++){
    //println(q);
var aVert = walls[i].data[q];
giveChunk(getChunk(aVert.x,aVert.y).x,getChunk(aVert.x,aVert.y).y,walls[i]);


var cVert = false;
if(q+1 !== walls[i].data.length){
cVert = walls[i].data[q+1];
}else{
cVert = walls[i].data[0];
}
if(cVert && dist(cVert.x,cVert.y,aVert.x,aVert.y) >= chunkSize){
var chunkA = getChunk(cVert.x,cVert.y);
var chunkB = getChunk(aVert.x,aVert.y);
//println('e');
//println(getBetween(chunkA.x,chunkA.y,chunkB.x,chunkB.y).length);
for(var z = 0; z < getBetween(chunkA.x,chunkA.y,chunkB.x,chunkB.y).length; z++){

giveChunk(getBetween(chunkA.x,chunkA.y,chunkB.x,chunkB.y)[z].x,getBetween(chunkA.x,chunkA.y,chunkB.x,chunkB.y)[z].y,walls[i]);
}
}
}



}
break;
case 'circle':
{
for(var z = -1-(floor(walls[i].data.r/chunkSize)); z < 2+(floor(walls[i].data.r/chunkSize)); z++){
for(var c = -1-(floor(walls[i].data.r/chunkSize)); c < 2+(floor(walls[i].data.r/chunkSize)); c++){
giveChunk(getChunk(walls[i].data.x,walls[i].data.y).x+z,getChunk(walls[i].data.x,walls[i].data.y).y+c,walls[i]);
}
}
}
break;
}
}
scene = 'game';
// if(loadCount < walls.length-1 && !loadRewind){
// loadCount++;
// loadCount = round(loadCount);
// }
};
// working good load system
var loadChunksb = function(){
var i = loadCount;
//println(toLoad[i].owner.type);
switch(toLoad[i].owner.type){
case 'polygon':
{
    //println(q);
var aVert = toLoad[i].point;
giveChunk(getChunk(aVert.x,aVert.y).x,getChunk(aVert.x,aVert.y).y,[aVert,toLoad[i].owner]);


var cVert = false;
if(toLoad[i].pos+1 !== toLoad[i].owner.data.length){
cVert = toLoad[i].owner.data[toLoad[i].pos+1];
}else{
cVert = toLoad[i].owner.data[0];
}
if(cVert && dist(cVert.x,cVert.y,aVert.x,aVert.y) >= chunkSize){
//if(cVert){
//{
var chunkA = getChunk(cVert.x,cVert.y);
var chunkB = getChunk(aVert.x,aVert.y);
//println('e');
var between = getBetween(chunkA.x,chunkA.y,chunkB.x,chunkB.y);
for(var z = 0; z < between.length; z++){
//println('e');
giveChunk(between[z].x,between[z].y,[aVert,toLoad[i].owner]);
//giveChunk(between[z].x,between[z].y,[cVert,toLoad[i].owner]);
}
}




}
break;
case 'circle':
{
for(var z = -1-(floor(toLoad[i].owner.data.r/chunkSize)); z < 2+(floor(toLoad[i].owner.data.r/chunkSize)); z++){
for(var c = -1-(floor(toLoad[i].owner.data.r/chunkSize)); c < 2+(floor(toLoad[i].owner.data.r/chunkSize)); c++){
giveChunk(getChunk(toLoad[i].owner.data.x,toLoad[i].owner.data.y).x+z,getChunk(toLoad[i].owner.data.x,toLoad[i].owner.data.y).y+c,[toLoad[i].owner.data,toLoad[i].owner]);
}
}
}
break;
}

//scene = 'game';
// if(loadCount < walls.length-1 && !loadRewind){
// loadCount++;
// loadCount = round(loadCount);
// }
};
// backup of b because it worked and if i make it not work anymore then i have a backup
var loadChunksc = function(){
var i = loadCount;
//println(toLoad[i].owner.type);
switch(toLoad[i].owner.type){
case 'polygon':
{
    //println(q);
var aVert = toLoad[i].point;
giveChunk(getChunk(aVert.x,aVert.y).x,getChunk(aVert.x,aVert.y).y,toLoad[i].owner);


var cVert = false;
if(toLoad[i].pos+1 !== toLoad[i].owner.data.length){
cVert = toLoad[i].owner.data[toLoad[i].pos+1];
}else{
cVert = toLoad[i].owner.data[0];
}
if(cVert && dist(cVert.x,cVert.y,aVert.x,aVert.y) >= chunkSize){
var chunkA = getChunk(cVert.x,cVert.y);
var chunkB = getChunk(aVert.x,aVert.y);
//println('e');
var between = getBetween(chunkA.x,chunkA.y,chunkB.x,chunkB.y);
for(var z = 0; z < between.length; z++){
//println('e');
giveChunk(between[z].x,between[z].y,toLoad[i].owner);
}
}




}
break;
case 'circle':
{
for(var z = -1-(floor(toLoad[i].owner.data.r/chunkSize)); z < 2+(floor(toLoad[i].owner.data.r/chunkSize)); z++){
for(var c = -1-(floor(toLoad[i].owner.data.r/chunkSize)); c < 2+(floor(toLoad[i].owner.data.r/chunkSize)); c++){
giveChunk(getChunk(toLoad[i].owner.data.x,toLoad[i].owner.data.y).x+z,getChunk(toLoad[i].owner.data.x,toLoad[i].owner.data.y).y+c,toLoad[i].owner);
}
}
}
break;
}

//scene = 'game';
// if(loadCount < walls.length-1 && !loadRewind){
// loadCount++;
// loadCount = round(loadCount);
// }
};
//loadChunks = DeKhan.loopDetect(loadChunks);  
function clearPath(x,y,x2,y2){
var ret = true;

var dir = atan2(y2-y,x2-x);
var bDist = dist(x,y,x2,y2);

var num = bDist/5;

for(var i = 0; i < num; i++){
var retx = x + (cos(dir) * ((bDist / num) * i));
var rety = y + (sin(dir) * ((bDist / num) * i));
var rend = toRenderAt(retx,rety);
//println(rend[0][1].data.length);
for(var q = 0; q < rend.length; q++){
switch(rend[q][1].type){
case 'polygon':
if(isInside(rend[q][1].data, rend[q][1].data.length, {x:retx,y:rety})){
ret = false;
return false;
//println(q);
}
break;
case 'circle':
if(dist(retx,rety,rend[q][1].data.x,rend[q][1].data.y) <= rend[q][1].data.r){
ret = false;
return false;
}
break;
}
}
}

return ret;
}
function fatClearPath(x,y,x2,y2,pl){
var ret = true;

var dir = atan2(y2-y,x2-x);
var bDist = dist(x,y,x2,y2);

var num = bDist/5;

for(var i = 0; i < num; i++){
var retx = x + (cos(dir) * ((bDist / num) * i));
var rety = y + (sin(dir) * ((bDist / num) * i));
var rend = toRenderAt(retx,rety);
//println(rend[0][1].data.length);
for(var q = 0; q < rend.length; q++){
switch(rend[q][1].type){
case 'polygon':
if(isInside(rend[q][1].data, rend[q][1].data.length, {x:retx,y:rety})){
ret = false;
return false;
//println(q);
}
break;
case 'circle':
if(dist(retx,rety,rend[q][1].data.x,rend[q][1].data.y) <= rend[q][1].data.r){
ret = false;
return false;
}
break;
}
}
}

return ret;
}
function obsFrom(x,y,x2,y2,pl){
var ret = [];

var dir = atan2(y2-y,x2-x);
var bDist = dist(x,y,x2,y2);

var num = bDist/5;

for(var i = 0; i < num; i++){
var retx = x + (cos(dir) * ((bDist / num) * i));
var rety = y + (sin(dir) * ((bDist / num) * i));
var rend = toRenderAt(retx,rety,pl);
//println(rend[0][1].data.length);
for(var q = 0; q < rend.length; q++){
switch(rend[q][1].type){
case 'polygon':
if(isInside(rend[q][1].data, rend[q][1].data.length, {x:retx,y:rety})){
ret.push([{x:retx,y:rety},rend[q][1]]);
//println(q);
}
break;
case 'circle':
if(dist(retx,rety,rend[q][1].data.x,rend[q][1].data.y) <= rend[q][1].data.r){
ret.push([{x:retx,y:rety},rend[q][1]]);
}
break;
}
}
}

return ret;
}
function player(){
this.x = 0; this.y = 0;
this.px = 0; this.py = 0;
this.vx = 0; this.vy = 0; this.trot = 0; this.onUseRot = false;
this.size = 1; this.rot = 0; this.charge = 0;
this.tCount = 0; this.pCharge = 0;  this.pUsed = false; this.pcUsed = false; this.powerSelect = 0;
this.selected = 0; this.attacked = false;
this.cooldown = 1000; this.handMove = 'punch'; this.currentPath = 0; this.pCooldown = [1000,1000,1000,1000,1000,1000,1000,1000];
this.color = color(245, 245, 245); this.name = 'random person';
this.health = 10; this.acc = 0.1; this.weapons = [];
this.use = weapons[0][1];
this.handMove = this.use.anim;
this.sweeping = false; this.pAttacked = false;
this.sweepRad = this.use.sweep;
this.stun = false; this.stunTimer = 0;
this.onSwingRot = false; this.newTargTimer = 0; this.newpTargTimer = 0;
this.que = []; this.hitYet = [];this.enemies = [];
this.hands = [{transX:0,transY:0},{transX:0,transY:0}];
this.keep = false; this.dirs = []; this.targDir = 0; this.colCount = 0;
players.push(this);
}
function getWeaponStats(e){
for(var i = 0; i < weapons.length; i++){
if(weapons[i][0] === e){
return weapons[i][1];
}
}
}
function getAbilityStats(e){
for(var i = 0; i < abilities.length; i++){
if(abilities[i][0] === e){
//println(abilities[i][1].swing);
return abilities[i][1];
}
}
}
function getPowerStats(e){
for(var i = 0; i < powers.length; i++){
if(powers[i][0] === e){
//println(abilities[i][1].swing);
return powers[i][1];
}
}
}
function drawWeapon(name, e, c, pos) {
    e.hands = [{transX:0,transY:0},{transX:0,transY:0}];
    if(db && e.use){
    pushMatrix();
    resetMatrix();
    stroke(0, 255, 4);
    line(e.x,e.y,e.x+cos(e.rot)*((e.size*e.use.reach)+(30*e.size/2)),e.y+sin(e.rot)*((e.size*e.use.reach)+(30*e.size/2)));
    stroke(255, 0, 0);
    line(e.x,e.y,e.x+cos(e.rot+e.use.sweep)*80,e.y+sin(e.rot+e.use.sweep)*80);
    line(e.x,e.y,e.x+cos(e.rot-e.use.sweep)*80,e.y+sin(e.rot-e.use.sweep)*80);
    popMatrix();
    }
    
    stroke(0, 0, 0);
    strokeWeight(2);
    pushMatrix();
    if(pos){
    translate(e.x, e.y);
    }
    // if(e.size !== 1){
    // scale(e.size);
    // }
    var toRotate = e.rot;
    if(pos){
    rotate(toRotate);
    }
    strokeWeight(2);

    //melee
    {
        if(name.includes('wooden')) {
            fill(102, 56, 15);
            stroke(0, 0, 0);
        }
        if(name.includes('stone')) {
            fill(140, 140, 140);
            stroke(0, 0, 0);
        }
        if(name.includes('iron')) {
            fill(219, 219, 219);
            stroke(0, 0, 0);
        }
        if(name.includes('steel')) {
            fill(92, 92, 92);
            stroke(0, 0, 0);
        }
        if(name.includes('heavy')) {
            fill(28, 28, 28);
            stroke(0, 0, 0);
        }
        if(name.includes('fire')) {
            fill(214, 92, 21);
            stroke(0, 0, 0);
        }
        if(name.includes('geist')) {
            fill(207, 58, 202);
            stroke(18, 18, 18);
            //x,y,r,c,t,t2,tp
            if(!pos){
            var geistPart = new effect(e.x+cos(toRotate)*20+random(-20,20),e.y+sin(toRotate)*20+random(-20,20),random(1,15),choice(color(128, 0, 128),color(0, 0, 0)),random(0,100),random(3,6));
            geistPart.vx = random(-0.4,0.4);
            geistPart.vy = random(-0.4,0.4);
            }
        }
        if(name.includes('dragon scale')) {
            fill(150, 9, 9);
            stroke(0, 0, 0);
        }
        if(name.includes('isaac')) {
            fill(0, 255, 111);
            stroke(0, 0, 0);
        }
        if(name.includes('lazer beam')){
        fill(143, 0, 143,100);
        noStroke();
        if(e.cooldown < 1 || !e.cooldown){
        ellipse(25,0,20,20);
        }
        if(e.cooldown < 1){
        for(var q = 0; q<2; q++){
        ellipse(25+random(-3,3),random(-3,3),20,20);
        }
        }
        }
        if(name.includes('greatsword')){
            e.hands = [{transX:8,transY:0},{transX:5,transY:0}];
pushMatrix();
scale(0.4);
translate(-150,-70);
//just some variables I used to make matching the colors easier
var crossguardColor = color(138, 138, 138);
var goldenHighlight = color(207, 203, 79);
strokeWeight(5);


//blade
//fill(255, 255, 255);
beginShape();
vertex(185, 179);
vertex(187, 256);
vertex(179, 245);
vertex(188, 485);
vertex(217, 485);
vertex(226, 245);
vertex(218, 256);
vertex(220, 179);
endShape(CLOSE);
// for (var i = 0; i < 3; i+=1) {
// noStroke();    
// fill(189, 189, 189, 100);
// rect(i*3+(3/4)+188, 180, 20, 305);    
// }
noFill();
//stroke(0, 0, 0);
beginShape();
vertex(190, 179);
vertex(192, 269);
vertex(184, 259);
vertex(193, 485);
vertex(212, 485);
vertex(221, 259);
vertex(213, 269);
vertex(215, 179);
endShape(CLOSE);
line(221, 260, 226, 246);
line(184, 260, 179, 246);


//crossguard
fill(crossguardColor);
beginShape();
vertex(183, 180);
vertex(192, 180);
vertex(203, 195);
vertex(213, 180);
vertex(222, 180);
bezierVertex(248, 150, 250, 180, 286, 160);
bezierVertex(248, 145, 250, 172, 217, 140);
vertex(189, 140);
bezierVertex(155, 172, 155, 145, 118, 160);
bezierVertex(155, 180, 164, 150, 183, 180);
endShape(CLOSE);
beginShape();
vertex(190, 140);
vertex(217, 140);
bezierVertex(210, 120, 279, 156, 237, 209);
bezierVertex(255, 214, 291, 133, 217, 120);
vertex(191, 120);
bezierVertex(149, 122, 126, 169, 167, 209);
bezierVertex(133, 148, 190, 128, 190, 136);
endShape(CLOSE);
fill(goldenHighlight);
rect(239, 156, 5, 9);
rect(160, 156, 5, 9);
triangle(198, 181, 208, 181, 203, 189);
noFill();
ellipse(203, 160, 30, 28);
//image(getImage("creatures/Winston"), 193, 151, 20, 20);

arc(224, 171, 145, 121, 145, 212);
arc(182, 171, 145, 121, 329, 399);
arc(179, 161, 95, 25, 526, 556);
line(126, 160, 131, 160);
arc(225, 161, 95, 25, 705, 735);
line(273, 160, 277, 160);


//hilt
fill(goldenHighlight);
rect(194, 24, 18, 11);
fill(crossguardColor);
rect(196, 35, 14, 7);
rect(195, 42, 14, 10);
fill(goldenHighlight);
rect(196, 52, 14, 5);
fill(crossguardColor);
rect(196, 57, 14, 11);
rect(196, 68, 14, 10);
rect(197, 78, 14, 11);
fill(goldenHighlight);
rect(196, 89, 14, 7);
fill(crossguardColor);
rect(196, 96, 14, 16);
fill(goldenHighlight);
rect(191, 111, 24, 8);


fill(goldenHighlight);
beginShape();
vertex(198, 2);
bezierVertex(186, 16, 189, 30, 203, 29);
bezierVertex(229, 31, 214, -1, 209, 2);
bezierVertex(221, 25, 188, 25, 199, 2);
endShape(CLOSE);
fill(255, 0, 0);
ellipse(203,161,20,20);
popMatrix();
        }else if(name.includes('sword')) {
                pushMatrix();
                // if(c < 10){
                // translate(8-(c / (10 / 8)),0);
                // }
                beginShape();
                vertex(28, 7);
                vertex(28, 14);
                vertex(38, 16);
                vertex(48, 10.5);
                vertex(38, 5);
                endShape(CLOSE);
                fill(102, 56, 15);
                rect(15, 6.5, 10, 5);
                rect(23, 4.5, 5, 10);
                popMatrix();
        }
        if(name.includes('stick')) {
            pushMatrix();
                // if(c < 10){
                // translate(8-(c / (10 / 8)),0);
                // }
                fill(102, 56, 15);
                rect(15, 6.5, 35, 4);
                
            popMatrix();
        }
        if(name.includes('katana')) {
            
            pushMatrix();
                // if(c < 10){
                // translate(8-(c / (10 / 8)),0);
                // }
                beginShape();
                vertex(28, 8);
                vertex(28, 13);
                vertex(58, 12);
                vertex(70, 9);
                vertex(70, 6);
                vertex(28, 8);
                endShape(CLOSE);
                fill(102, 56, 15);
                rect(15, 6.5, 10, 5);
                rect(23, 4.5, 5, 10);
            popMatrix();
        }
        if(name.includes('dagger')) {
            pushMatrix();
                // if(c < 10){
                // translate(8-(c / (10 / 8)),0);
                // }
                beginShape();
                vertex(25, 7);
                vertex(25, 14);
                vertex(30, 15);
                vertex(43, 10.5);
                vertex(30, 6);
                endShape(CLOSE);
                fill(102, 56, 15);
                rect(15, 6.5, 10, 5);
                rect(21, 5, 5, 9.5);
            popMatrix();
        }
        if(name.includes('spear')) {
            e.hands = [{transX:10,transY:10},{transX:0,transY:0}];
            pushMatrix();
            translate(20,-3);
                // if(c < 10){
                // translate(8-(c / (10 / 8)),0);
                // }
                triangle(70, 6.5, 70, 12.5, 81, 9.5);
                stroke(0, 0, 0);
            popMatrix();
                fill(102, 56, 15);
                rect(15, 7.5-3, 74, 3);
            
        }
        if(name.includes('staff')) {
            pushMatrix();
                // if(c < 10){
                // translate(-8+ (c / (10 / 8)),0);
                // }
                triangle(9, -20, 15, -20, 12, -25);
                triangle(15, -20, 21, -20, 18, -25);
                rect(9, -20, 12, 5);
                fill(59, 59, 59);
                rect(15, -15, 3, 35);
            popMatrix();
        }
        if(name.includes('axe')) {
            e.hands = [{transX:0,transY:-3},{transX:0,transY:3}];
            pushMatrix();
                // if(c < 10){
                // translate(-8+ (c / (10 / 8)),0);
                // }
                pushMatrix();
                translate(0,-30);
                
                triangle(-10, -10, 15, -20, -10, -30);
                triangle(40,-10, 15, -20, 40, -30);
                rect(9, -25, 12, 10);
                popMatrix();
                fill(59, 59, 59);
                rect(15, -45, 3, 65);
                
            popMatrix();
        }
        if(name.includes('BURRITO')) {
            textSize(30);
            fill(0, 0, 0);
            pushMatrix();
            rotate(33);

            textAlign(LEFT, BASELINE);
            text('ðŸŒ¯', 0, -5);
            popMatrix();
        }
    }
    //ranged
    {
        strokeWeight(2);
        if(name.includes('wooden')) {
            fill(102, 56, 15);
            stroke(102, 56, 15);
        }
        if(name.includes('stone')) {
            fill(140, 140, 140);
            stroke(140, 140, 140);
        }
        if(name.includes('iron')) {
            fill(219, 219, 219);
            stroke(105, 105, 105);
        }
        if(name.includes("crime boss'")) {
            fill(255, 196, 0);
            stroke(255, 196, 0);
        }
        if(name.includes("artemis")) {
            fill(99, 70, 35);
            stroke(74, 57, 3);
        }
        if(name.includes('hailstorm')) {

            fill(255, 255, 255);
            stroke(199, 199, 199);
        }
        if(name.includes('bow')) {
            pushMatrix();
                // if(c < 10){
                // translate(-8+ (c / (10 / 8)),0);
                // }
                if(e.charge){
                e.hands = [{transX:0,transY:-2},{transX:0,transY:-10}];
                }else{
                e.hands = [{transX:0,transY:-2},{transX:0,transY:2}];
                }
                
                noFill();
                strokeWeight(4);
                arc(14, 0, 20, 40, 270, 450);
                if(name.includes('recurve bow')){
                arc(14, -25.5, 4, 9, 90, 270);
                arc(14, 25.5, 4, 9, 90, 270);
                }else{
                arc(14, -25.5, 4, 9, 90, 200);
                arc(14, 25.5, 4, 9, 160, 270);
                }
                stroke(0,0,0);
                strokeWeight(2);
                //line(11, -25, 11, 25);
                line(11, -25, 11-e.charge, 0);
                line(11, 25, 11-e.charge, 0);
                if(e.charge > 0){
                pushMatrix();
                if(e.charge < 5){
                translate(10,0);
                rotate(100-e.charge*20);
                translate(-10,-0);
                }
                translate(-e.charge+25,0);
                projGraphics(e.use.type);
                popMatrix();
                }
            popMatrix();
        }
        if(name.includes('retribution')) {
            pushMatrix();
                // if(c < 10){
                // translate(-8+ (c / (10 / 8)),0);
                // }
                // noStroke();

                rect(5, -23, 10, 3);
                rect(5, 20, 10, 3);

                noFill();

                strokeWeight(4);
                arc(14, 0, 20, 40, 270, 450);

                stroke(0, 0, 0);
                strokeWeight(2);
                line(11, -25, 11, 25);
                strokeWeight(2.5);
                stroke(84, 84, 84);
                line(20, -3, 27, -3);
                line(20, 3, 27, 3);
            popMatrix();
        }
        if(name.includes('dragon breath')){
                    fill(133, 0, 0);
                    
                    // if(c < 10){
                    // pushMatrix();
                    // translate(0,((10-c)/2));
                    // triangle(12 + c / (10 / 8),12,22 + c / (10 / 8),10,2 + c / (10 / 8),10);
                    // triangle(9 + c / (10 / 8),9,19 + c / (10 / 8),7,-1 + c / (10 / 8),7);
                    // triangle(15 + c / (10 / 8),15,19 + c / (10 / 8),13,5 + c / (10 / 8),13);
                    
                    // popMatrix();
                    
                    // pushMatrix();
                    // translate(0,-((10-c)/2));
                    // triangle(12 + c / (10 / 8),-12,22 + c / (10 / 8),-10,2 + c / (10 / 8),-10);
                    // triangle(9 + c / (10 / 8),-9,19 + c / (10 / 8),-7,-1 + c / (10 / 8),-7);
                    // triangle(15 + c / (10 / 8),-15,19 + c / (10 / 8),-13,5 + c / (10 / 8),-13);
                    // popMatrix();
                    // // triangle(21 + c / (10 / 8),-9,19 + c / (10 / 8),-7,-15 + c / (10 / 8),-7);
                    // // triangle(19 + c / (10 / 8),-12,-5 + c / (10 / 8),-12,-10 + c / (10 / 8),-1);
                    // // triangle(17 + c / (10 / 8),-16,7 + c / (10 / 8),-15,-10 + c / (10 / 8),-1);
                    // }else{
                    triangle(20,12,30,10,10,10);
                    triangle(17,9,27,7,7,7);
                    triangle(23,15,27,13,13,13);
                    
                    
                    triangle(20,-12,30,-10,10,-10);
                    triangle(17,-9,27,-7,7,-7);
                    triangle(23,-15,27,-13,13,-13);
                    //}
                    pushMatrix();
                    translate(5,0);
                    rotate(sin(frameCount*1.5)*15 + 7.5);
                    quad(-34,-5,-34,-13,-40,-25,5,-5);
                    popMatrix();
                    pushMatrix();
                    translate(5,0);
                    rotate(sin(frameCount*1.5)*-15 - 7.5);
                    quad(-34,5,-34,13,-40,25,5,5);
                    //quad(-24,5,-24,13,-30,25,5,10);
                    popMatrix();
        }
    }

    popMatrix();

}
function handa(x,y,e){
pushMatrix();
translate(e.hands[0].transX,e.hands[0].transY);
ellipse(x,y,10,10);
popMatrix();
}
function handb(x,y,e){
pushMatrix();
translate(e.hands[1].transX,e.hands[1].transY);
ellipse(x,y,10,10);
popMatrix();
}
function drawHands(e,c,t){

    pushMatrix();
    translate(e.x, e.y);
    if(e.size !== 1){
    scale(e.size);
    }
    rotate(e.rot);
    if(e.use.altAnim){
    t = e.use.altAnim;
    }
        pushMatrix();
        if(c < 10){
        switch(t){
        case 'twang':
        translate(8-(c / (10 / 8)),0);
        break;
        case 'stretch':
        translate(-8+(c / (10 / 8)),((10-c)/2));
        break;
        case 'throw':
        translate(-19+(c / (10 / 19)),((10-c)/2));
        break;
        case 'back':
        translate(-8+(c / (10 / 8)),0);
        break;
        case 'thrust':
        translate(8-(c / (10 / 8)),0);
        break;
        }
        }
        switch(t){
        case 'cast1':
        translate(0.5+sin(frameCount*2)*5,0);
        break;
        }
        drawWeapon(e.weapons[e.selected],e,c);
        popMatrix();
        fill(e.color);
        stroke(0, 0, 0);
    if(t === 'cast1'){    
        handa(8+abs(sin(frameCount*3))*7, -10+sin(frameCount*7)*4, e);
        handb(15.5+sin(frameCount*2)*5, 10, e);
        
    } else if(t === 'twang'&&c<10){    
        handa(23 - c / (10 / 8), -10,e);
        handb(23- e.charge - c / (10 / 8), 10,e);
    
    } else if(t === 'firebreath'&&c<10){    
        handa(7 + c / (10 / 8), -10-((10-c)/2),e);
        handb(7 + c / (10 / 8), 10+((10-c)/2),e);
    
    } else if(t === 'throw'&&c<10){    
        handa(-4 + c / (10 / 19), -10-((10-c)/2),e);
        handb(-4 + c / (10 / 19), 10+((10-c)/2),e);
    
    } else if(t === 'back'&&c<10){    
        handa(7 + c / (10 / 8), -10,e);
        handb(7 + c / (10 / 8), 10,e);
    } else if(t === 'thrust'&&c<10){
        
        handa(23 - c / (10 / 8), -10,e);
        handb(23 - c / (10 / 8), 10,e);
    } /*else if(t === 'sweep'&&e.sweeping){
    
    } */else if(t === 'punch'&&c<10){
        
        if(e.cooldown === 0){
        e.punchSide = floor(random(0,2));
        }
        
        switch(e.punchSide){
        case 0:
        handa(23 - c / (10 / 8), -10,e);
        handb(15, 10,e);
        break;
        case 1:
        handb(23 - c / (10 / 8), 10,e);
        handa(15, -10,e);
        break;
        }
    
    } else {
        
        e.sHandMove = 'none';
        drawWeapon(e.weapons[e.selected],e,c);
        fill(e.color);
        stroke(0, 0, 0);
        handa(15, -10,e);
        handb(15, 10,e);
    }
    popMatrix();
}
function d(a,b){
return dist(a.x,a.y,b.x,b.y);
}
function space(a,b){
return abs(a-b);
}
function angle(a,b){
return atan2(b.y-a.y,b.x-a.x);
}
function angleDiff(a,b){
//var diff = mod(b - a + 180, 360);
var diff = abs(b-a)+180;
while(diff >= 360){
diff -= 360;
}
diff = abs(diff-180);
return diff;
}
function hitDiff(a,b){
return (a.use.reach*a.size)+(getSize(b.size))+(getSize(a.size));
}
player.prototype.become = function(name){
for(var i = 0; i < people.length; i++){
if(people[i].name === name){
this.name = people[i].name;
this.color = people[i].color;
this.health = people[i].health;
this.maxHealth = this.health;
this.speed = people[i].speed;
this.acc = people[i].acceleration;
this.weapons = people[i].weapons;
this.use = getWeaponStats(people[i].weapons[0]);
this.size = people[i].size;
this.debugNum = i;
this.data = people[i];
this.powers = [];
for(var q = 0; q < this.data.powers.length; q++){
this.powers.push(getPowerStats(this.data.powers[q]));
}
}
}
};
player.prototype.switchPower = function(n){
p.pCharge = 0;
p.powerSelect+=n;
if(p.powerSelect >= p.powers.length){
p.powerSelect = 0;   
}
if(p.powerSelect < 0){
p.powerSelect = p.powers.length-1;
}
};
player.prototype.doPower = function(i){
//println(this.didPowerYet);
if(!this.stun && !this.noPower){
   
if(this.pCooldown[i] > this.powers[i].cooldown){
//println(i+' , '+this.didPowerYet+' , '+frameCount);
//this.pUsed = i;
this.pcUsed = i;
this.powers[i].use(this);
if(this.powers[i].lockRot){
this.onUseRot = this.rot;
this.pChangeRot = false;
}
if(this.powers[i].changeRot){
this.onUseRot = this.rot;
this.pChangeRot = this.powers[i].changeRot;
}
if(this.powers[i].noHold){
this.pCooldown[i] = 0;
}
}
}
this.noPower = false;
};
player.prototype.hit = function(e,w,k){
this.hitYet.push(e);
    for(var a = 0; a < w.abilities.length; a++){
    
    var stats = getAbilityStats(w.abilities[a]);
    if(stats){
    if(stats.hit){
    stats.hit(this,e);
    }
    }
    }
    e.knockback(k,w.knockback);
    e.health -= w.damage;
    var dmgNotif = new effect(e.x,e.y,0,color(255, 0, 0),255,5,"btext");
    dmgNotif.textSize = 30;
    dmgNotif.text = w.damage;
    dmgNotif.vx = random(-1,1);
    dmgNotif.vy = random(-2.5);
    dmgNotif.rot = 0;
    dmgNotif.vRot = random(-1,1);
};
player.prototype.checkForHits = function(){
var angMod = 0;
if(this.use.sweepMod){
angMod = this.use.sweepMod;
}
for(var q = this.enemies.length - 1; q > -1; q--){
    if(this.enemies[q]){
    //println('e');
    // if(this.use.sweep === 180){
    // if(players[q] !== this&&!this.hitYet.includes(players[q])){
    // if(d(this,players[q]) <= (this.use.reach*this.size)+(getSize(players[q].size))+(getSize(this.size))){
    // println(angleDiff(this.rot,angle(this,players[q])));
    // }
    // }
    // }
    if(this.enemies[q] !== this&&!this.hitYet.includes(this.enemies[q])){
        //println('e');
        //println( this.use.sweep+angMod);
    if(d(this,this.enemies[q]) <= hitDiff(this,this.enemies[q]) && angleDiff(this.rot,angle(this,this.enemies[q])) <= this.use.sweep+angMod){
        //println('e');
    var check = false;
    
    if(clearPath(this.x,this.y,this.enemies[q].x,this.enemies[q].y)){
    check = true;    
    }
    
    if(check){
    this.hit(this.enemies[q],this.use,this);
    }
    
    
    
    }
    }
    }
}
};
player.prototype.draw = function(){
    if(this.charge > 15){
    this.charge = 15;
    }
    if(this.pCharge > 15){
    this.pCharge = 15;
    }
    //this.didPowerYet = false;
    //println(this.pcUsed+' , '+this.pUsed);
    if(this.pcUsed === false && this.pUsed !== false){
    this.powers[this.pUsed].released(this);
    if(!this.powers[this.pUsed].noHold){
    this.pCooldown[this.pUsed] = 0;
    }
    }
    if(this.pcUsed === false){
    this.pCharge = 0;
    }
    this.pUsed = this.pcUsed;
    //this.pUsedN = this.pcUsed[0];
    this.pcUsed = false;
    
    while(space(this.rot,this.trot)>180){

    if(this.rot > this.trot){
    this.rot -= 360;
    }else if(this.rot < this.trot){
    this.rot += 360;
    }
    }
    
    if(this.onUseRot !== false){
    if(this.pChangeRot){
    this.rot = lerp(this.rot,this.trot,this.pChangeRot);
    }else{
    
    this.rot = this.onUseRot;
    }
    if(this.pCooldown[this.pUsed] > 1){
    this.onUseRot = false;
    }
    }else if(this.onSwingRot !== false){
    if(this.use.changeRot){


    this.rot = lerp(this.rot,this.trot,this.use.changeRot);
    }else{
    this.rot = this.onSwingRot;
    }
    if(this.cooldown > 1){
    this.onSwingRot = false;
    }
    }else{
        
    
    this.rot = lerp(this.rot,this.trot,0.2);
    }
    if(this.health > 0){
    
    this.px = this.x;
    this.py = this.y;
    var amp = 1;
    var shake = false;
    if(this.altSpeed){
    amp = this.altSpeed;
    }
    this.altSpeed = false;
    if(this.use.slow){
    amp = this.use.slow;
    }
    if(this.cooldown <= 1){
    if(this.use.useSlow){
    amp = this.use.useSlow;
    }
    }
    if(this.que[0]){
    if(this.que[0].type === 'delay'){
    amp = this.que[0].slow;
    shake = 5;
    }
    }
    
    this.tvx = this.vx*amp;
    this.tvy = this.vy*amp;
    //var totalV = (this.tvx+this.tvy)/2;
    
    this.tvx = constrain(this.tvx,-getSize(this.size/1.2),getSize(this.size/1.2));
this.tvy = constrain(this.tvy,-getSize(this.size/1.2),getSize(this.size/1.2));

    this.x += this.tvx;
    this.y += this.tvy;
    this.x = round(this.x * 10) / 10;
    this.y = round(this.y * 10) / 10;
    this.health = round(this.health*100)/100;
    pushMatrix();
    
    if(shake){
    translate(this.x,this.y);
    rotate(random(-shake,shake));
    translate(-this.x,-this.y);
    }
    
    pushMatrix();
    translate(this.x,this.y);
    //rotate(this.rot);
    if(this.attacked && this.cooldown <= 1 && !this.que[0]){
    //
    for(var a = 0; a < this.use.abilities.length; a++){
    var stats = getAbilityStats(this.use.abilities[a]);
    if(stats){
    if(stats.duringSwing){
    stats.duringSwing(this);
    }
    } 
    }
    }else{
    if(this.pAttacked && this.cooldown <= 1){
    for(var a = 0; a < this.use.abilities.length; a++){
    var stats = getAbilityStats(this.use.abilities[a]);
    if(stats){
    if(stats.released){
    stats.released(this);
    }
    } 
    }
    }
    }

    if(this.sweeping){
    this.selected = this.keep;
    var mod = 0;
    if(this.use.swingMod){
    mod = this.use.swingMod;
    }
    
    if(this.use.invert){
    rotate(this.sweepRad-(((this.sweepRad*2)/this.use.swingDuration)*this.cooldown)+mod);
    }else{
    rotate(-this.sweepRad+(((this.sweepRad*2)/this.use.swingDuration)*this.cooldown)+mod);
    }
    if(this.cooldown > this.use.swingDuration){
    this.sweeping = false;
    for(var a = 0; a < this.use.abilities.length; a++){
    var stats = getAbilityStats(this.use.abilities[a]);
    if(stats){
    if(stats.endSwing){
    stats.endSwing(this);
    }
    } 
    }
    }
    if(this.cooldown < this.use.swingDuration){
    this.checkForHits();
    }
    }
    translate(-this.x,-this.y);
    
    fill(this.color);
    stroke(0, 0, 0);
    strokeWeight(2);
    drawHands(this,this.cooldown,this.handMove);
    popMatrix();
    pushMatrix();
    translate(this.x,this.y);
    scale(this.size);
    translate(-this.x,-this.y);
    fill(this.color);
    stroke(0, 0, 0);
    strokeWeight(2);
    ellipse(this.x, this.y, 30, 30);  
    
    // if(this.target){
    // line(this.x,this.y,this.x+cos(angle(this,this.target))*20,this.y+sin(angle(this,this.target))*20);
    // }
    popMatrix();
    popMatrix();
    noStroke();
    fill(255, 0, 0);
    rect(this.x - 25, this.y - 30, 50, 8);
    fill(0, 255, 4);
    stroke(0, 255, 4);
    strokeWeight(2);
    rect(this.x - 25, this.y - 30, (50 / round(this.maxHealth)) * (round(this.health*100)/100), 8);
    fill(0, 0, 0);
    textSize(8);
    textAlign(CENTER, BOTTOM);
    text(round(this.health) + '/' + this.maxHealth, this.x, this.y - 21);

    textSize(9);
    text(this.name, this.x, this.y - 34);
    if(this === p){
    stroke(255, 0, 0,200);
    strokeWeight(3);
    for(var i = 0; i < players.length; i++){
    if(players[i] !== this){
    var dir = angle(this,players[i]);
    line(this.x,this.y,this.x+cos(dir)*10,this.y+sin(dir)*10);
    }
    }
    }
    if(this.stun){
    pushMatrix();
    translate(this.x,this.y);
    scale(this.size);
    translate(-this.x,-this.y);
    noStroke();
    fill(255, 183, 0,128);
    ellipse(this.x, this.y, 40, 40);
    popMatrix();
    pushMatrix();
    translate(random(-1,1),random(-1,1));
    fill(255, 30, 0);
    textSize(20);
    textAlign(CENTER,BASELINE);
    text('stun',this.x,this.y-30);
    popMatrix();
    }
    this.cooldown += 1;
    for(var i = 0; i < this.powers.length; i++){
    this.pCooldown[i] += 1;
    }
    this.pAttacked = this.attacked;
    this.pTrueAttacked = this.trueAttacked;
    this.attacked = false;
    this.trueAttacked = false;
    }
};
proj.prototype.draw = function() {
noStroke();
this.x += cos(this.angle)*this.v;
this.y += sin(this.angle)*this.v;
if(this.data.slow || this.data.slow === 0){
this.v -= this.data.slow;
}else{
this.v -= 0.1;
}
if(this.v <= 0 && !this.data.rebound){
this.v = 0;
}
pushMatrix();
translate(this.x,this.y);
scale(this.data.shooter.size);
rotate(this.angle);
fill(255, 0, 0);
noStroke();
//println('e');
//ellipse(0,0,10,10);
projGraphics(this.data.data.type);
var rend = toRenderAt(this.x,this.y);
for(var q = 0; q < rend.length; q++){
switch(rend[q][1].type){
case 'polygon':
if(isInside(rend[q][1].data, rend[q][1].data.length, this)){
this.life = 0;
}
break;
case 'circle':
if(dist(this.x,this.y,rend[q][1].data.x,rend[q][1].data.y) <= rend[q][1].data.r){
this.life = 0;
}
break;
}
}

for(var i = 0; i < this.data.shooter.enemies.length; i++){
var e = this.data.shooter.enemies[i];
if(dist(this.x,this.y,e.x,e.y)<getSize(e.size)){
if(this.data.shooter){
this.data.shooter.hit(e,this.data.data,this);
}
this.life = 0;
break;
}
}

popMatrix();
this.life -= 1;
if(this.life <= 0||(this.v<=1&&!this.data.noStall)){
for(var i = 0; i < projs.length; i++){
if(projs[i] === this){
projs.splice(i,1);
}
}
}
};
player.prototype.move = function(dirs){
//move
if(this.cooldown <= 1&&this.use.swingStill){
dirs = [false,false,false,false];
}
if(this.stun){
dirs = [false,false,false,false];
this.stunTimer--;
if(this.stunTimer <= 0){
this.stun = false;
}
}
        {
        //up / down
        if(dirs[0]) {
            
            if(this.vy > -1 * this.speed) {

                this.vy = this.vy - this.acc;
            }
            if(this.vy < -1 * this.speed) {

                this.vy = this.vy + this.acc;
            }

        } else if(dirs[2]) {
            if(this.vy < this.speed) {
                this.vy = this.vy + this.acc;
            }
            if(this.vy > this.speed) {
                this.vy = this.vy - this.acc;
            }
        } else {
            this.vy = round(this.vy * 100) / 100;
            if(this.vy > 0) {
                this.vy = this.vy - this.acc;
            } else if(this.vy < 0) {
                this.vy = this.vy + this.acc;
            }
            if(space(this.vy,0) <= 0.1){
            this.vy = 0;
            }
        }

        //left / right
        if(dirs[3]) {
            
            if(this.vx < this.speed) {
                this.vx = this.vx + this.acc;
            }
            if(this.vx > this.speed) {
                this.vx = this.vx - this.acc;
            }
        } else if(dirs[1]) {
           
            if(this.vx > -1 * this.speed) {
                this.vx = this.vx - this.acc;
            }
            if(this.vx < -1 * this.speed) {
                this.vx = this.vx + this.acc;
            }
        } else {
            this.vx = round(this.vx * 100) / 100;
            if(this.vx > 0) {
                
                this.vx = this.vx - this.acc;
            } else if(this.vx < 0) {
                this.vx = this.vx + this.acc;
            }
            if(space(this.vx,0) <= 0.1){
            this.vx = 0;
            }
        }
        //prevents moving to fast

        // {
        //     if(this.vy > this.speed) {
        //         this.vy = this.speed;
        //     }
        //     if(this.vy < this.speed) {
        //         this.vy = this.speed;
        //     }
        //     if(this.vx > this.speed) {
        //         this.vx = this.speed;
        //     }
        //     if(this.vx < this.speed) {
        //         this.vx = this.speed;
        //     }
        // }

        this.vy = round(this.vy * 100) / 100;
        this.vx = round(this.vx * 100) / 100;
        }
};
player.prototype.switchWeapon = function(n){
if(!this.que[0]){
for(var i = 0; i < weapons.length; i++){
if(weapons[i][0] === this.weapons[n]){
this.selected = n;
this.use = weapons[i][1];
this.charge = 0;
if(this.cooldown < 2){
this.cooldown = 2;
}
}
}
}
};
player.prototype.knockback = function(e,n){
var dir = atan2(e.y-this.y,e.x-this.x);
this.vx -= cos(dir)*n;
this.vy -= sin(dir)*n;
};
player.prototype.procede = function(i){
    this.cooldown = 0;
    this.use = weapons[i][1];
    this.handMove = this.use.anim;
    if(this.handMove === 'sweep'){
    this.sweeping = true;
    this.sweepRad = this.use.sweep;
    for(var e = 0; e < this.sweepRad; e+=2){
    new effect(this.x+cos(this.rot+e*2-this.sweepRad)*(this.use.reach+15)*this.size,this.y+sin(this.rot+e*2-this.sweepRad)*(this.use.reach+15)*this.size,random(2,10)*this.size,color(59, 59, 59),random(0,255),random(3,6));
    }
    }
    for(var a = 0; a < this.use.abilities.length; a++){
    var stats = getAbilityStats(this.use.abilities[a]);

    if(stats){
    
    if(stats.swing){
    
    stats.swing(this);
    }
    }
    }
    this.checkForHits();
};
player.prototype.doQue = function(){
if(this.que[0]){
this.cooldown = 0;
switch(this.que[0].type){
case 'delay':
this.que[0].counter -= 1;
this.selected = this.que[0].num;
//println('e');
this.rot = this.que[0].rot;
if(this.que[0].counter <= 0){
this.procede(this.que[0].i);
this.que.splice(0,1);
}
break;
}
}
};
player.prototype.attack = function(){
    if(!this.stun){
    this.attacked = true;
    this.noPower = true;
for(var i = 0; i < weapons.length; i++){
    if(weapons[i][0] === this.weapons[this.selected]){
    if(this.cooldown >= weapons[i][1].cooldown){
    //this.trueAttacked = true;
    this.hitYet = [];
    this.cooldown = 0;
    this.use = weapons[i][1];
    this.handMove = this.use.anim;
    this.keep = this.selected;
    this.onSwingRot = this.rot;
    if(this.use.delay){
    this.que.push({
    type:'delay',
    counter:this.use.delay[0],
    num: this.selected,
    slow: this.use.delay[1],
    rot: this.rot,
    i:i,
    });
    }else{
    this.procede(i);
    }
    }
    }
    
}
}
};
player.prototype.canSee = function(e){
if(space(this.x,e.x) <= 300+getSize(e.size)&&space(this.y,e.y) <= 300+getSize(e.size)){

if(clearPath(this.x,this.y,e.x,e.y)){
return true;
}
}
};
player.prototype.alignDirs = function(){
//strokeWeight(10);
//stroke(255, 0, 0);
//line(this.x,this.y,this.x+cos(this.targDir)*100,this.y+sin(this.targDir)*100);

if((this.target && this.target.name)&&(this.target && this.use.idealDist&&this.target&&this.target.name&&d(this,this.target)<(this.use.idealDist+getSize(this.target.size)))){
if(this.targDir > -90&&this.targDir <= 90){
this.dirs[1] = true;
}else{
this.dirs[3] = true;
}
if(this.targDir > 0){
this.dirs[0] = true;
}else{
this.dirs[2] = true;
}
}else{
if(this.targDir > -90&&this.targDir <= 90){
this.dirs[3] = true;
}else{
this.dirs[1] = true;
}
if(this.targDir > 0){
this.dirs[2] = true;
}else{
this.dirs[0] = true;
}
}
// }else{
// if(this.targDir < 90||this.targDir >= 270){
// this.dirs[3] = true;
// }else{
// this.dirs[1] = true;
// }
// if(this.targDir > 180){
// this.dirs[0] = true;
// }else{
// this.dirs[2] = true;
// }
// }
};
player.prototype.checkForKill = function(){
if(this.health <= 0){
for(var i = players.length-1; i > -1; i--){
for(var q = players.length-1; q > -1; q--){
if(players[q].enemies.indexOf(this) >= 0){
//println('e');
players[q].enemies.splice(players[q].enemies.indexOf(this),1);
}
}
if(players[i] === this){
players.splice(i,1);
}
}
}
};
function injectPath(p,e,pos){
var ret = [];
for(var i = 0; i < p.length+1; i++){
if(i < pos-1){
    
ret.push(p[i]);
}else if(i === pos-1){
   
ret.push([
    {
    x:p[i][0].x,
    y:p[i][0].y,
    },
    {
    x:e.x,
    y:e.y,
    },
    ]);
}else if(i === pos){
     
ret.push([
    {
    x:e.x,
    y:e.y,
    },
    {
    x:p[i-1][1].x,
    y:p[i-1][1].y,
    },
    ]);
}else{
ret.push(p[i-1]);
}
}

return ret;
}
function allObsAlong(p,pl){
var ret = [];
for(var i = 0; i < p.length; i++){
var obs = obsFrom(p[i][0].x,p[i][0].y,p[i][1].x,p[i][1].y,pl);
for(var q = 0; q < obs.length; q++){
ret.push([obs[q],p[i],i]);
}
}
return ret;
}
function resetPath(a,b){
var ret = [];
ret.push([
    {
    x:a.x,
    y:a.y
    },
    {
    x:b.x,
    y:b.y
    },
    ]);
return ret;
}
function decideDir(a,b){
var xd = a.x-b.x;
var yd = a.y-b.y;
if(abs(xd) < abs(yd)){
return 'x';
}else{
return 'y';
}
}
function minim(a,b){
if(a<b){
return a;
}else{
return b;
}
}
function maxim(a,b){
if(a>=b){
return a;
}else{
return b;
}
}
function chunksFrom(a,b){
var mini={x:minim(a.x,b.x),y:minim(a.y,b.y)};
var maxi={x:maxim(a.x,b.x),y:maxim(a.y,b.y)};
var chunkA = mini;
var chunkB = maxi;
var ret = [];
//println('a');
for(var i = chunkA.y; i < chunkB.y; i++){
ret[i] = [];
//println('b');
for(var q = chunkA.x; q < chunkB.x; q++){

ret[i][q] = chunks[i][q];

}

}
//println('c');
return ret;
}


function noNest(e){
var ret = e;
println(e.length);

return ret;
}

function changePath(p,e,pos){
var ret = p;
if(pos-1 >= 0){
ret[pos-1][1] = e;
}
ret[pos][0] = e;
return ret;
}
function findWay(position, f) {
  var queue = [];
  
  var matrix = chunksFrom({x:position[1],y:position[0]},{x:f[1],y:f[0]});
  
  //println('d');
  if(!matrix[position[0]]){
  matrix[position[0]] = [];
  
  }
  //println('e');
  matrix[position[0]][position[1]] = 1;
//println('f');
  queue.push([position]); // store a path, not just a position
  
  while (queue.length > 0) {
    var path = queue.shift(); // get the path out of the queue
    var pos = path[path.length-1]; // ... and then the last position from it
    //println('g');
    var direction = [
      [pos[0] + 1, pos[1]],
      [pos[0], pos[1] + 1],
      [pos[0] - 1, pos[1]],
      [pos[0], pos[1] - 1],
    ];

    for (var i = 0; i < direction.length; i++) {
      // Perform this check first:
    if (direction[i][0] === f[0] && direction[i][1] === f[1]) {
        // return the path that led to the find
        return path.concat([f]); 
      }
//if (direction[i][0] < 0  || direction[i][1] < 0 || matrix[direction[i][0]][direction[i][1]] !== 0) { 
    //    continue;
    //  }
    //println('h');
    if(!matrix[direction[i][0]]){
  matrix[direction[i][0]] = [];
  
  }
      matrix[direction[i][0]][direction[i][1]] = 1;
      //println('i');
      // extend and push the path on the queue
      queue.push(path.concat([direction[i]])); 
    }
  }
  //println('j');
}
player.prototype.getPath = function(e){
var ret = [];
var int = pathfindingInt;
var lastRot = Infinity;
this.currentPath = 0;
for(var i = 0; i < 1000/int; i++){

var cont = false;
var past = {x:this.x,y:this.y};
if(ret.length-1 >= 0){
past = ret[ret.length-1][1];
}
var dir = angle(past,e);
var dir2 = angle(past,e);
while(dir < 360 && cont === false){
ret.push([{x:past.x,y:past.y},{x:past.x+cos(dir)*int,y:past.y+sin(dir)*int}]);
var last = ret[ret.length-1];
dir++;

if(round(dir) !== round(lastRot+180) && round(dir) !== round(lastRot-180) && fatClearPath(last[0].x,last[0].y,last[1].x,last[1].y,this)){
cont = true;
lastRot = dir;
continue;
}else{
ret.splice(ret.length-1,1);
}
ret.push([{x:past.x,y:past.y},{x:past.x+cos(dir2)*int,y:past.y+sin(dir2)*int}]);
var last = ret[ret.length-1];
dir2--;
if(round(dir2) !== round(lastRot+180) && round(dir2) !== round(lastRot-180) &&fatClearPath(last[0].x,last[0].y,last[1].x,last[1].y,this)){
cont = true;
lastRot = dir2;
continue;
}else{
ret.splice(ret.length-1,1);
}
}
}

return ret;
};
player.prototype.doAi = function(){
this.newTargTimer += 1;
this.newpTargTimer += 1;
if(!this.attacked){
if(round(random(0,240)) === 4){

this.switchWeapon(round(random(0,this.weapons.length-1)));

}
}
this.dirs = [false,false,false,false];
if(this.newTargTimer > 0){
if(this.newpTargTimer > 60){
for(var i = this.enemies.length-1; i > -1; i--){
if(this.enemies[i] !== this){
if(round(random(0,10)) === 5){
var e = this.enemies[i];
if(space(this.x,e.x) <= 300+getSize(e.size)&&space(this.y,e.y) <= 300+getSize(e.size)){
if(clearPath(this.x,this.y,e.x,e.y)){
this.target = e;
this.newpTargTimer = 0;
}
}
}
}
}
}
}
//this.target = p;
//ellipse(500,-500,50,50);
// if(this.target){

// this.targDir = angle(this.target,this)+180;
// //println(this.targDir);
// if(this.collided){
// if(this.colCount < 100){
// if(!(this.contAttack||this.que[0])){
// this.targDir = this.collided[1]+180+random(-90,90);
// this.target = false;
// this.newTargTimer = 0;
// }
// }
// }
// }else{
    
// if(round(random(0,50)) === 10){
// this.targDir = random(0,360);
// }
// if(this.collided){
// //println('e');
// if(this.colCount < 100){
// this.targDir = this.collided[1]+180+random(-90,90);
// }
// }
// }

if(this.target){
if(this.target.name){
// if the target is a player
this.targDir = angle(this,this.target);
if(this.colCount > 100){
this.path = false;
this.currentPath = 0;
this.target = false;
this.newTargTimer = 0;
}
}else{
// if the target is not a player
if(this.path){
// if has a path, follow path
// for(var i = 0; i < this.path.length; i++){
// strokeWeight(10);
// stroke(255, 0, 0);
// line(this.path[i][0].x,this.path[i][0].y,this.path[i][1].x,this.path[i][1].y);
// }

this.targDir = angle(this,this.path[this.currentPath][1]);
//println(d(this,this.path[this.path.length-1][1]));
if(d(this,this.path[this.currentPath][1])<getSize(this.size)*2){
    
if(this.currentPath < this.path.length-1){
this.currentPath++;
}
}

if(d(this,this.path[this.path.length-1][1])<=getSize(this.size)*2){
this.path = false;
this.currentPath = 0;
this.target = false;
}
if(this.colCount > 100){
this.path = false;
//println(frameCount);
this.colCount = 0;

this.currentPath = 0;
this.target = false;
this.newTargTimer = 0;
}
}else{
// if no path, make a path

this.path = this.getPath(this.target);
}

}
}else{
// if no target, make a target somewhere random on the map
if(this.tCount > 3 || !this.target){
this.tCount = 0;
this.target = {x:random(this.x-1000,this.x+1000),y:random(this.y-1000,this.y+1000)};
this.pTarget = this.target;
}else{
this.target = this.pTarget;
}

//println(this.target.x);
}

this.trot = this.targDir;

if(this.health <= 0){

}else{

if(this.target){
if(this.target.name){
if(!players.includes(this.target)){
this.path = false;
this.currentPath = 0;
this.target = false;
}
if(round(random(0,10))===5||this.contAttack){
this.contAttack = false;
if(d(this,this.target) <= this.use.aiDist*this.size+(getSize(this.target.size))+(getSize(this.size))){
//if(!this.hitYet.includes(this.target)){


//}
this.attack();
if(this.use.abilities.includes("dart")){
if(abs(this.vx)+abs(this.vy)>0&&!this.hitYet.includes(this.target)){
this.contAttack = true;
}
}else if(this.use.abilities.includes('continuous')){
if((this.charge < 15 || space(this.rot,this.trot) > random(0,30))&&space(this.rot,this.trot) < 90){
this.contAttack = true;
}
}

}
}
}
}
}
if(this.onSwingRot !== false){
    if(this.use.changeRot){
    
if(this.rot > this.targDir+2){
this.trot -= 70;
}
if(this.rot < this.targDir-2){
this.trot += 70;
}
}
}
//println(this.vx);
//this.attack();
//println(this.vx);
//strokeWeight(10);
//stroke(255, 0, 0);
//line(this.x,this.y,this.x+cos(this.targDir)*100,this.y+sin(this.targDir)*100);
this.alignDirs();

};
player.prototype.initiate = function(){
    //println('e');
for(var i = 0; i < players.length; i++){
    //println('e');
if(players[i] !== this){
this.enemies.push(players[i]);
}
}
};
p = new player();
p.x = 300;
p.y = 300;
p.become('ack');
p.size = 1;
player.prototype.initiate2 = function(){
    //println('e');
this.enemies.push(p);
};
function wall(e,d,s){
this.data = d;
this.type = e;
this.texture = s;
this.loadRew = 0;
walls.push(this);
}
wall.prototype.shadow = function(e){
noStroke();
fill(0, 0, 0);
switch(this.type){
case 'polygon':
{
for(var i = 0; i < this.data.length; i++){
var dir = atan2(this.data[i].y-e.y, this.data[i].x-e.x);
var dir2;
if(this.data[i+1]){
dir2 = atan2(this.data[i+1].y-e.y, this.data[i+1].x-e.x);
}else{
dir2 = atan2(this.data[0].y-e.y, this.data[0].x-e.x);
}
/*
vertex(120,90);
vertex(120+cos(rot)*80,90+sin(rot)*80);
vertex((120+cos(rot)*80)+cos(rot+90)*210,(90+sin(rot)*80)+sin(rot+90)*210);
vertex(120+cos(rot+90)*210,90+sin(rot+90)*210);
*/
beginShape();
vertex(this.data[i].x, this.data[i].y);
vertex(this.data[i].x+cos(dir)*10000, this.data[i].y+sin(dir)*10000);
//vertex(this.data[i].x+cos(dir+90)*1000, this.data[i].y+sin(dir+90)*1000);
if(this.data[i+1]){
vertex(this.data[i+1].x+cos(dir2)*10000, this.data[i+1].y+sin(dir2)*10000);
vertex(this.data[i+1].x, this.data[i+1].y);
}else{
vertex(this.data[0].x+cos(dir2)*10000, this.data[0].y+sin(dir2)*10000);
vertex(this.data[0].x, this.data[0].y);
}
endShape(CLOSE);
// beginShape();
// vertex(this.data[i].x, this.data[i].y);
// vertex(this.data[i].x+cos(dir)*600, this.data[i].y+sin(dir)*600);
// if(this.data[i-1]){
// vertex(this.data[i-1].x, this.data[i-1].y);
// }else{
// vertex(this.data[this.data.length-1].x, this.data[this.data.length-1].y);
// }
// endShape(CLOSE);
}
}
break;
case 'circle':
{

var dir = atan2(this.data.y-e.y,this.data.x-e.x)+90;
var dir2 = dir+180;
var dir3 = atan2((this.data.y+sin(dir)*this.data.r)-e.y,(this.data.x+cos(dir)*this.data.r)-e.x);
var dir4 = atan2((this.data.y+sin(dir2)*this.data.r)-e.y,(this.data.x+cos(dir2)*this.data.r)-e.x);
beginShape();
vertex(this.data.x+cos(dir)*this.data.r,this.data.y+sin(dir)*this.data.r);
vertex(this.data.x+cos(dir3)*this.data.r*6000,this.data.y+sin(dir3)*this.data.r*6000);
vertex(this.data.x+cos(dir4)*this.data.r*6000,this.data.y+sin(dir4)*this.data.r*6000);
vertex(this.data.x+cos(dir2)*this.data.r,this.data.y+sin(dir2)*this.data.r);

endShape(CLOSE);

}

break;
}
};
wall.prototype.draw = function(highlight) {
pushMatrix();
if(this.texture.stroke){
stroke(this.texture.stroke);
if(this.texture.strokeWeight !== false){
strokeWeight(this.texture.strokeWeight);
if(this.texture.strokeWeight === 0){
noStroke();
}
}else{
strokeWeight(2);
}
}else{
noStroke();
}
if(this.texture.fill){
fill(this.texture.fill);
}else{
fill(130, 130, 130);
}
if(highlight){
fill(255, 0, 0);
}else if(showChunkCollisions){

var rend = fatRenderAt(p.x,p.y,p);
//println(rend.length);
for(var i = 0; i < rend.length; i++){
    
if(rend[i][1] === this){
    
fill(255, 0, 0);
}
}

}
switch(this.type){
case 'polygon':
beginShape();
for(var i = 0; i < this.data.length; i++){
vertex(this.data[i].x, this.data[i].y);
}
if(this.data[0]||this.data[1]){
vertex(this.data[0].x, this.data[0].y);
vertex(this.data[1].x, this.data[1].y);
}
endShape(CLOSE);
break;
case 'circle':
ellipse(this.data.x,this.data.y,this.data.r*2,this.data.r*2);
break;
}
popMatrix();
};
wall.prototype.destroy = function(){
for(var i = 0; i < walls.length; i++){
if(walls[i] === this){
walls.splice(i,1);
}
}
};
wall.prototype.rot = function(rot){
if(rot !== 0){
var center;
if(this.type === 'polygon'){
center = getCenter(this);
}else{
center = {
x:this.data.x,
y:this.data.y,
};
}
for(var i = 0; i < this.data.length; i++){
var bDist = dist(center.x,center.y,this.data[i].x,this.data[i].y);
var ang1 = atan2(center.y-this.data[i].y,center.x-this.data[i].x);
this.data[i] = {
x:center.x+cos(rot+ang1)*bDist,
y:center.y+sin(rot+ang1)*bDist,
};
}
}
};
function drawWalls(e){
// var rend = toRenderAt(e.x,e.y);
// for(var i = 0; i < rend.length; i++){
// rend[i].draw();
// }
for(var i = walls.length-1; i > -1; i--){
walls[i].draw();
}
}

player.prototype.collide = function(e){
switch(e.type){
case 'polygon':
{
var nearest = function(){};
for(var i = 0; i < e.data.length; i++){

if(i+1 !== e.data.length){
nearest = nearestPointOnLine(e.data[i].x,e.data[i].y,e.data[i+1].x,e.data[i+1].y);
}else{
nearest = nearestPointOnLine(e.data[i].x,e.data[i].y,e.data[0].x,e.data[0].y);
}

var projection = nearest(this.x,this.y);

//getClosest(p,getTriCenter(w.data)).x,getClosest(p,getTriCenter(w.data)).y
//if((isInsideTri(e.data.x1, e.data.y1, e.data.x2, e.data.y2, e.data.x3, e.data.y3, getClosest(this,getTriCenter(e.data)).x, getClosest(this,getTriCenter(e.data)).y))){
// stroke(255, 0, 0);
// strokeWeight(20);
// point(projection.x,projection.y);

if(isInside(e.data, e.data.length, this)){
this.x = this.px;
this.y = this.py;
//println(q);
}

while((dist(this.x,this.y,projection.x,projection.y)<getSize(this.size))){
var dir = atan2(projection.y-this.y,projection.x-this.x);
this.x -= cos(dir);
this.y -= sin(dir);
this.collided = [true,dir,e,i];
// this.vx = 0;
// this.vy = 0;
}
}
//}
}
break;
case 'circle':
{
var dir = atan2(e.data.y-this.y,e.data.x-this.x);
while(dist(e.data.x,e.data.y,this.x,this.y) < getSize(this.size)+e.data.r){
this.x -= cos(dir);
this.y -= sin(dir);
this.collided = [true,dir,e,false];
}
}
break;
}

};
player.prototype.collideSingular = function(e,o){
switch(o.type){
case 'polygon':
{
var nearest = function(){};
var i = o.data.indexOf(e);
//println(walls.indexOf(o));
// for(var q = 0; q < o.data.length; q++){
// if(o.data[q] === e){
// i = q;
// }
// }
//getClosest(p,getTriCenter(w.data)).x,getClosest(p,getTriCenter(w.data)).y
//if((isInsideTri(e.data.x1, e.data.y1, e.data.x2, e.data.y2, e.data.x3, e.data.y3, getClosest(this,getTriCenter(e.data)).x, getClosest(this,getTriCenter(e.data)).y))){


if(isInside(o.data, o.data.length, this)){
this.x = this.px;
this.y = this.py;
//println(i);
}
//var nearest = function(){};
if(i+1 !== o.data.length){
nearest = nearestPointOnLine(e.x,e.y,o.data[i+1].x,o.data[i+1].y);
}else{
nearest = nearestPointOnLine(e.x,e.y,o.data[0].x,o.data[0].y);
}

var projection = nearest(this.x,this.y);

if(showChunkCollisions){
stroke(255, 0, 0);
strokeWeight(20);
point(projection.x,projection.y);
//println(i);
}

while((dist(this.x,this.y,projection.x,projection.y)<getSize(this.size))){
var dir = atan2(projection.y-this.y,projection.x-this.x);
this.x -= cos(dir);
this.y -= sin(dir);
this.collided = [true,dir,o,i];
// this.vx = 0;
// this.vy = 0;
}

if(i-1 >= 0){
nearest = nearestPointOnLine(e.x,e.y,o.data[i-1].x,o.data[i-1].y);
}else{
nearest = nearestPointOnLine(e.x,e.y,o.data[o.data.length-1].x,o.data[o.data.length-1].y);
}

var projection = nearest(this.x,this.y);

while((dist(this.x,this.y,projection.x,projection.y)<getSize(this.size))){
var dir = atan2(projection.y-this.y,projection.x-this.x);
this.x -= cos(dir);
this.y -= sin(dir);
this.collided = [true,dir,o,i];
// this.vx = 0;
// this.vy = 0;
}

//}
}
break;
case 'circle':
{
this.collide(o);
}
break;
}

};
player.prototype.collisions = function(){
this.collided = false;
this.colCount -= 1;
this.colCount = constrain(this.colCount,0,105);
// for(var z = -1; z < 2; z++){
// for(var c = -1; c < 2; c++){
// var rend = toRenderAt(this.x+(z*chunkSize),this.y+(c*chunkSize));
// for(var i = 0; i < rend.length; i++){
// //this.collide(rend[i]);
// //println(rend[i][1].type);
// this.collideSingular(rend[i][0],rend[i][1]);
// }
// }
// }
var rend = fatRenderAt(this.x,this.y,this);
//var rend = allRenderAt(this.x,this.y);
//println(rend.length);
for(var i = 0; i < rend.length; i++){
//this.collide(rend[i]);
//println(rend[i][1].type);
this.collideSingular(rend[i][0],rend[i][1]);
}
if(this.collided){
this.colCount += 2;
}
};
var presets = [
    ['polygon',
    function(x,y,s,r,w){
    w.data = [];
    for(var i = 0; i < s; i++){
    w.data.push({
    x:x+cos(i*(360/s))*r,
    y:y+sin(i*(360/s))*r,
    });
    }
    }],
    ['tree',
    function(x,y,s,r,w){
    w.data = [];
    for(var i = 0; i < s; i++){
    w.data.push({
    x:x+cos(i*(360/s))*r,
    y:y+sin(i*(360/s))*r,
    });
    w.data.push({
    x:x+cos(i*(360/s)+((360/s)/2))*r/1.5,
    y:y+sin(i*(360/s)+((360/s)/2))*r/1.5,
    });
    }
    }],
    ['circle',
    function(x,y,s,r,w){
    w.data = {x:x,y:y,r:r};
    w.type = 'circle';
    }],
    ['rock',
    function(x,y,s,r,w){
    w.data = [];
    w.texture.fill = color(148, 148, 148);
    for(var i = 0; i < s; i++){
    w.data.push({
    x:x+cos(i*(360/s))*r+sin(i*725)*100,
    y:y+sin(i*(360/s))*r,
    });
    }
    }],
    ['rock2',
    function(x,y,s,r,w){
    w.data = [];
    w.texture.fill = color(120, 120, 120);
    for(var i = 0; i < s; i++){
    w.data.push({
    x:x+cos(i*(360/s))*r+sin(i*715)*100,
    y:y+sin(i*(360/s))*r,
    });
    }
    }],
    ];
wall.prototype.preset = function(type,x,y,s,r){
for(var i = 0; i < presets.length; i++){
if(presets[i][0] === type){
presets[i][1](x,y,s,r,this);
}
}
};
var waveFade = 255;



// Paste here
{
//begin
var w = new wall('polygon',[],{
stroke:color(0, 0, 0),
strokeWeight:5,
fill:color(125, 186, 125),
});
w.preset('tree',Infinity,Infinity,2,79);
//0
var w = new wall('polygon',[],{
stroke:color(0, 0, 0),
strokeWeight:5,
fill:color(125, 186, 125),
});
w.preset('tree',77.4148897346833,193.32981936166925,5,79);
//1
var w = new wall('polygon',[],{
stroke:color(0, 0, 0),
strokeWeight:5,
fill:color(125, 186, 125),
});
w.preset('tree',411.64812240145295,826.239557815765,5,79);
//2
var w = new wall('polygon',[],{
stroke:color(0, 0, 0),
strokeWeight:5,
fill:color(125, 186, 125),
});
w.preset('tree',507.65128497595066,221.77520086522412,6,104);
//3
var w = new wall('polygon',[],{
stroke:color(0, 0, 0),
strokeWeight:5,
fill:color(125, 186, 125),
});
w.preset('tree',-71.92336315897978,637.788905354714,5,36);
//4
var w = new wall('polygon',[],{
stroke:color(0, 0, 0),
strokeWeight:5,
fill:color(125, 186, 125),
});
w.preset('tree',361.86870477023194,556.0084335319938,5,50);
//5
var w = new wall('polygon',[],{
stroke:color(0, 0, 0),
strokeWeight:5,
fill:color(125, 186, 125),
});
w.preset('tree',-384.8225596980833,139.99472904250388,5,50);
//6
var w = new wall('polygon',[],{
stroke:color(0, 0, 0),
strokeWeight:5,
fill:color(125, 186, 125),
});
w.preset('tree',450.7605219688409,-258.2406120072643,5,50);
//7
var w = new wall('polygon',[],{
stroke:color(0, 0, 0),
strokeWeight:5,
fill:color(125, 186, 125),
});
w.preset('rock',710.3246281887791,616.4548692270479,5,50);
//8
var w = new wall('polygon',[],{
stroke:color(0, 0, 0),
strokeWeight:5,
fill:color(125, 186, 125),
});
w.preset('rock',-214.15027067675408,392.4474898865533,5,50);
//9
var w = new wall('polygon',[],{
stroke:color(0, 0, 0),
strokeWeight:5,
fill:color(125, 186, 125),
});
w.preset('rock',1005.4454612881608,164.88443785811438,5,50);
w.rot(33);
//10
var w = new wall('polygon',[],{
stroke:color(0, 0, 0),
strokeWeight:5,
fill:color(125, 186, 125),
});
w.preset('rock',2.745763287851787,-212.01686706398755,6,74);
//11
var w = new wall('polygon',[
{
x:1147.672368805935,
y:602.2321784752705,
},
{
x:1193.896113749212,
y:602.2321784752705,
},
{
x:1204.563131813045,
y:829.7952305037094,
},
{
x:1510.3509829762597,
y:826.239557815765,
},
{
x:1506.7953102883152,
y:122.21636560278208,
},
{
x:1417.9034930897064,
y:-59.12294148238021,
},
{
x:1247.2312040683773,
y:-69.78995954621325,
},
{
x:1176.11775030949,
y:22.65753034034003,
},
{
x:1186.784768373323,
y:143.55040173044824,
},
{
x:1147.672368805935,
y:143.55040173044824,
},
{
x:1140.5610234300466,
y:29.768875716228763,
},
{
x:1222.3414952527667,
y:-94.67966836182376,
},
{
x:1435.6818565294282,
y:-98.23534104976812,
},
{
x:1542.352037167759,
y:122.21636560278208,
},
{
x:1553.019055231592,
y:890.2416661987635,
},
{
x:1154.7837141818238,
y:883.1303208228748,
},],{
stroke:color(0, 0, 0),
strokeWeight:5,
fill:color(89, 53, 23),
});
//12
var w = new wall('polygon',[
{
x:1133.4496780541576,
y:271.55461849644513,
},
{
x:1153.4971143749055,
y:264.25794840234573,
},
{
x:1237.4088204570485,
y:494.803466090946,
},
{
x:1217.3613841363006,
y:502.1001361850454,
},],{
stroke:color(0, 0, 0),
strokeWeight:5,
fill:color(89, 53, 23),
});
//13
var w = new wall('polygon',[],{
stroke:color(0, 0, 0),
strokeWeight:5,
fill:color(189, 135, 10),
});
w.preset('polygon',1326.766512692526,168.3632676035223,6,74);
//14
var w = new wall('polygon',[],{
stroke:color(0, 0, 0),
strokeWeight:5,
fill:color(0, 0, 0),
});
w.preset('circle',1364.7949020515084,691.9849364695114,6,34);
//15
var w = new wall('polygon',[],{
stroke:color(0, 0, 0),
strokeWeight:5,
fill:color(74, 74, 74),
});
w.preset('circle',-108.95144864505755,811.3355738423177,6,34);
//16
var w = new wall('polygon',[],{
stroke:color(0, 0, 0),
strokeWeight:5,
fill:color(74, 74, 74),
});
w.preset('circle',-91.39988432552718,875.6913096805956,6,34);
//17
var w = new wall('polygon',[],{
stroke:color(0, 0, 0),
strokeWeight:5,
fill:color(74, 74, 74),
});
w.preset('circle',-53.37149496654473,934.1965240790302,6,34);
//18
var w = new wall('polygon',[],{
stroke:color(0, 0, 0),
strokeWeight:5,
fill:color(74, 74, 74),
});
w.preset('circle',10.98424087173322,948.8228276786388,6,34);
//19
var w = new wall('polygon',[],{
stroke:color(0, 0, 0),
strokeWeight:5,
fill:color(74, 74, 74),
});
w.preset('circle',75.3399767100112,928.3460026391867,6,34);
//20
var w = new wall('polygon',[],{
stroke:color(0, 0, 0),
strokeWeight:5,
fill:color(74, 74, 74),
});
w.preset('circle',127.99466966860228,896.1681347200478,6,34);
//21
var w = new wall('polygon',[],{
stroke:color(0, 0, 0),
strokeWeight:5,
fill:color(74, 74, 74),
});
w.preset('circle',133.84519110844573,831.8123988817697,6,34);
//22
var w = new wall('polygon',[],{
stroke:color(0, 0, 0),
strokeWeight:5,
fill:color(74, 74, 74),
});
w.preset('circle',-76.77358072591858,752.8303594438831,6,34);
//23
var w = new wall('polygon',[],{
stroke:color(0, 0, 0),
strokeWeight:5,
fill:color(74, 74, 74),
});
w.preset('circle',-24.118887767327465,717.7272308048224,6,34);
//24
var w = new wall('polygon',[
{
x:-1035.1365995027325,
y:429.60640794601807,
},
{
x:-973.1923604108854,
y:420.07652500881085,
},
{
x:-892.188355444624,
y:639.263832564577,
},
{
x:-658.706223483047,
y:715.5028960622349,
},
{
x:-382.33961830403746,
y:577.31959347273,
},
{
x:-563.4073941109748,
y:162.7696857042158,
},
{
x:-487.1683306133169,
y:-113.59691947479371,
},
{
x:-77.38336431340633,
y:-342.3141099677671,
},
{
x:-201.27184249710024,
y:-685.3898957072272,
},
{
x:-596.7619843912,
y:-847.39790563975,
},
{
x:-1154.2601362178227,
y:-775.9237836106959,
},
{
x:-1392.5072096480033,
y:-523.3818857747044,
},
{
x:-1344.857794961967,
y:-494.7922369630827,
},
{
x:-1139.9653118120118,
y:-733.0393103932633,
},
{
x:-601.5269258598037,
y:-790.2186080165068,
},
{
x:-239.39137424592911,
y:-647.2703639583983,
},
{
x:-129.79772046804607,
y:-361.3738758421815,
},
{
x:-510.993037956335,
y:-166.01127562943344,
},
{
x:-611.0568087970108,
y:138.9449783611977,
},
{
x:-425.22409152147,
y:558.2598275983156,
},
{
x:-653.9412820144433,
y:677.3833643134059,
},
{
x:-873.1285895702094,
y:610.6741837529553,
},
{
x:-958.8975360050745,
y:377.19205179137833,
},
{
x:-1044.6664824399395,
y:391.4868761971892,
},],{
stroke:color(0, 0, 0),
strokeWeight:5,
fill:color(110, 117, 110),
});
//25
var w = new wall('polygon',[
{
x:-1182.8497850294443,
y:415.3115835402072,
},
{
x:-1039.9015409713359,
y:658.3235984389914,
},
{
x:-1125.670487406201,
y:672.6184228448024,
},
{
x:-1197.1446094352552,
y:815.5666669029107,
},
{
x:-1430.6267413968321,
y:858.4511401203432,
},
{
x:-1492.5709804886792,
y:734.5626619366492,
},
{
x:-1497.3359219572828,
y:486.7857055692614,
},
{
x:-1444.921565802643,
y:482.0207641006578,
},
{
x:-1459.216390208454,
y:729.7977204680456,
},
{
x:-1421.0968584596249,
y:815.5666669029107,
},
{
x:-1225.7342582468768,
y:786.977018091289,
},
{
x:-1159.0250776864264,
y:648.7937155017842,
},
{
x:-1092.3158971259757,
y:629.7339496273698,
},
{
x:-1220.9693167782732,
y:415.3115835402072,
},],{
stroke:color(0, 0, 0),
strokeWeight:5,
fill:color(110, 117, 110),
});
//26
var w = new wall('polygon',[
{
x:-1101.845780063183,
y:850.8272337705771,
},
{
x:-935.0728286620565,
y:898.4766484566132,
},
{
x:-763.5349357923265,
y:788.8829946787303,
},
{
x:-734.9452869807049,
y:812.7077020217482,
},
{
x:-930.3078871934529,
y:950.891004611253,
},
{
x:-1111.3756630003902,
y:884.1818240508024,
},],{
stroke:color(0, 0, 0),
strokeWeight:5,
fill:color(110, 117, 110),
});
//27
var w = new wall('polygon',[
{
x:-1161.8840425675885,
y:-411.8822554093798,
},
{
x:-895.0473203257864,
y:-511.94602625005564,
},
{
x:-632.9755395525876,
y:-230.8144796024426,
},
{
x:-937.9317935432189,
y:140.85095494863918,
},
{
x:-1095.174862007138,
y:-2.097289109469159,
},
{
x:-1228.5932231280392,
y:212.32507697769336,
},
{
x:-1276.2426378140754,
y:174.20554522886448,
},
{
x:-1095.174862007138,
y:-59.27658673271253,
},
{
x:-947.4616764804259,
y:74.14177438818862,
},
{
x:-690.154837175831,
y:-221.2845966652353,
},
{
x:-899.81226179439,
y:-459.53167009541596,
},
{
x:-1128.5294522873633,
y:-383.2926065977582,
},],{
stroke:color(0, 0, 0),
strokeWeight:5,
fill:color(110, 117, 110),
});
//28
var w = new wall('polygon',[
{
x:-1423.9558233407872,
y:-402.35237247217265,
},
{
x:-1514.489711244256,
y:-221.2845966652353,
},
{
x:-1509.7247697756522,
y:-78.33635260712697,
},
{
x:-1471.6052380268234,
y:-92.63117701293783,
},
{
x:-1466.8402965582197,
y:-216.51965519663167,
},
{
x:-1390.601233060562,
y:-383.2926065977582,
},],{
stroke:color(0, 0, 0),
strokeWeight:5,
fill:color(110, 117, 110),
});
//29
var w = new wall('polygon',[
{
x:-1509.7247697756522,
y:21.72741823354886,
},
{
x:-1714.6172529256075,
y:136.08601348003558,
},
{
x:-1747.9718432058328,
y:312.38884781836924,
},
{
x:-1500.194886838445,
y:374.3330869102162,
},
{
x:-1485.9000624326343,
y:317.1537892869728,
},
{
x:-1681.2626626453823,
y:288.56414047535117,
},
{
x:-1676.4977211767787,
y:140.85095494863918,
},
{
x:-1452.5454721524088,
y:45.55212557656694,
},],{
stroke:color(0, 0, 0),
strokeWeight:5,
fill:color(110, 117, 110),
});
//30
var w = new wall('polygon',[],{
stroke:color(0, 0, 0),
strokeWeight:5,
fill:color(158, 81, 143),
});
w.preset('polygon',-1533.5494771186702,202.79519404048614,6,34);
//31
var w = new wall('polygon',[],{
stroke:color(0, 0, 0),
strokeWeight:5,
fill:color(99, 63, 0),
});
w.preset('circle',-967.8817670671997,-224.1772676567574,6,63);
//32
var w = new wall('polygon',[],{
stroke:color(0, 0, 0),
strokeWeight:5,
fill:color(99, 63, 0),
});
w.preset('polygon',-579.6023095436757,-560.1883366674994,6,82);
//33
var w = new wall('polygon',[],{
stroke:color(0, 0, 0),
strokeWeight:5,
fill:color(99, 63, 0),
});
w.preset('polygon',-336.92764859147326,-418.31699641851947,4,82);
//34
var w = new wall('polygon',[],{
stroke:color(0, 0, 0),
strokeWeight:5,
fill:color(99, 63, 0),
});
w.preset('polygon',-721.4736497926556,410.51030714131053,8,91);
//35
var w = new wall('polygon',[],{
stroke:color(0, 0, 0),
strokeWeight:5,
fill:color(189, 68, 179),
});
w.preset('circle',-638.5909194366725,480.6992860013321,8,36);
//36
var w = new wall('polygon',[],{
stroke:color(0, 0, 0),
strokeWeight:5,
fill:color(189, 68, 179),
});
w.preset('circle',-560.1883366674995,611.3702572832873,8,36);
//37
var w = new wall('polygon',[],{
stroke:color(0, 0, 0),
strokeWeight:5,
fill:color(189, 68, 179),
});
w.preset('circle',-914.8666872899494,473.23237335664896,8,36);
//38
var w = new wall('polygon',[],{
stroke:color(0, 0, 0),
strokeWeight:5,
fill:color(189, 68, 179),
});
w.preset('circle',-537.78759873345,338.8279457523522,8,36);
//39
var w = new wall('polygon',[],{
stroke:color(0, 0, 0),
strokeWeight:5,
fill:color(219, 212, 136),
});
w.preset('circle',-1200.1027503168457,170.82241124698126,8,36);
//40
var w = new wall('polygon',[],{
stroke:color(0, 0, 0),
strokeWeight:5,
fill:color(219, 212, 136),
});
w.preset('circle',-1147.8343618040635,193.22314918103072,8,36);
//41
var w = new wall('polygon',[],{
stroke:color(0, 0, 0),
strokeWeight:5,
fill:color(219, 212, 136),
});
w.preset('circle',-1099.299429613623,189.48969285868915,8,36);
//42
var w = new wall('polygon',[],{
stroke:color(0, 0, 0),
strokeWeight:5,
fill:color(219, 212, 136),
});
w.preset('circle',-976.095370976351,114.82056641185761,8,36);
//43
var w = new wall('polygon',[],{
stroke:color(0, 0, 0),
strokeWeight:5,
fill:color(125, 186, 125),
});
w.preset('rock',-1315.8398963094346,603.9033446386042,5,60);
w.rot(-50);
//44
var w = new wall('polygon',[],{
stroke:color(0, 0, 0),
strokeWeight:5,
fill:color(125, 186, 125),
});
w.preset('rock',-1304.6395273424098,-209.99013363185952,5,60);
//45
var w = new wall('polygon',[],{
stroke:color(0, 0, 0),
strokeWeight:5,
fill:color(125, 186, 125),
});
w.preset('rock',-1252.3711388296276,-251.05815317761687,5,60);
w.rot(-80);
//46
var w = new wall('polygon',[],{
stroke:color(0, 0, 0),
strokeWeight:5,
fill:color(125, 186, 125),
});
w.preset('rock',-1181.4354687051377,-202.5232209871764,5,60);
w.rot(50);
//47
var w = new wall('polygon',[],{
stroke:color(0, 0, 0),
strokeWeight:5,
fill:color(125, 186, 125),
});
w.preset('rock',-991.0291962657175,-621.4170203539012,5,60);
w.rot(50);
//48
var w = new wall('polygon',[],{
stroke:color(0, 0, 0),
strokeWeight:5,
fill:color(125, 186, 125),
});
w.preset('rock',-135.32100718502767,-24.064008779249093,5,60);
w.rot(180);
//49
var w = new wall('polygon',[],{
stroke:color(0, 0, 0),
strokeWeight:5,
fill:color(125, 186, 125),
});
w.preset('rock2',816.7103550120743,-50.94489430010816,5,60);
//50
var w = new wall('polygon',[],{
stroke:color(0, 0, 0),
strokeWeight:5,
fill:color(125, 186, 125),
});
w.preset('rock2',865.2452872025148,370.93567012448995,5,32);
//51
var w = new wall('polygon',[],{
stroke:color(0, 0, 0),
strokeWeight:5,
fill:color(125, 186, 125),
});
w.preset('rock2',917.5136757152968,800.2831471937712,5,44);
//52
var w = new wall('polygon',[],{
stroke:color(0, 0, 0),
strokeWeight:5,
fill:color(125, 186, 125),
});
w.preset('tree',958.5816952610542,571.7956202664668,5,73);
//53
var w = new wall('polygon',[],{
stroke:color(0, 0, 0),
strokeWeight:5,
fill:color(125, 186, 125),
});
w.preset('tree',1085.519210220668,-260.7651396157047,5,49);
//54
var w = new wall('polygon',[],{
stroke:color(0, 0, 0),
strokeWeight:5,
fill:color(125, 186, 125),
});
w.preset('tree',678.572471085436,-361.56846031892735,5,49);
//55
var w = new wall('polygon',[],{
stroke:color(0, 0, 0),
strokeWeight:5,
fill:color(125, 186, 125),
});
w.preset('tree',290.293013561912,-47.95812924223486,5,49);
//56
var w = new wall('polygon',[],{
stroke:color(0, 0, 0),
strokeWeight:5,
fill:color(125, 186, 125),
});
w.preset('tree',241.75808137147152,-436.2375867657588,6,69);
//57
var w = new wall('polygon',[],{
stroke:color(0, 0, 0),
strokeWeight:5,
fill:color(125, 186, 125),
});
w.preset('tree',55.008392818061964,519.6476478182897,6,69);

//}
var w = new wall('polygon',[
{
x:-1527.550585196441,
y:-724.2908884581823,
},
{
x:-2021.7260138385464,
y:-328.9505455444978,
},
{
x:-2012.7410060450534,
y:470.7151480763637,
},
{
x:-1419.730491674527,
y:1081.695678033876,
},
{
x:395.2410826110239,
y:1126.62071700134,
},
{
x:1725.0222360479622,
y:1009.8156156859333,
},
{
x:1769.9472750154264,
y:-104.32535070717722,
},
{
x:1248.8168229928424,
y:-706.3208728711966,
},
{
x:-449.34964997730174,
y:-1155.571262545838,
},
{
x:-1536.5355929899338,
y:-733.275896251675,
},
{
x:-1545.5206007834265,
y:-787.1859430126319,
},
{
x:-449.34964997730174,
y:-1200.4963015133021,
},
{
x:1266.786838579828,
y:-742.260904045168,
},
{
x:1832.8423295698763,
y:-122.29536629416282,
},
{
x:1769.9472750154264,
y:1063.7256624468903,
},
{
x:413.21109819800955,
y:1189.5157715557898,
},
{
x:-1437.7005072615127,
y:1153.5757403818184,
},
{
x:-2057.6660450125173,
y:506.655179250335,
},
{
x:-2084.6210683929958,
y:-337.93555333799065,
},
{
x:-1509.5805696094553,
y:-796.1709508061249,
},],{
stroke:color(0, 0, 0),
strokeWeight:5,
fill:color(82, 82, 82),
});
}
// Paste here


for(var i = 0; i < 5; i++){
var h = new player();
h.x = 0;
h.y = 50;
h.become('ack');
//h.speed = 1;
//h.health = 1000;
h.size = 1;
h.switchWeapon(0);
}
// for(var i = 0; i < players.length; i++){
// players[i].initiate2();
// }
//p.initiate();
//loadChunks();
var trans = {};
var zoom = 1;
for(var i = 0; i < players.length; i++){
players[i].initiate();
}
//newWave();
var startMillis = millis();
var framesYet = 0;
var fr = 0;
getActualMouse = function(){

return {
x:(-trans.x+(mouseX-300))*zoom+(300),
y:(-trans.y+(mouseY-300))*zoom+(300),
};
};
function loadBit(sMillis,reMar){
loadCount++;
loadCount = round(loadCount);
try{
loadChunksb();
}catch(e){
println(e+': Error with chunk loading!');
}
var eMillis = millis()-startMillis;
if(eMillis-sMillis < reMar){
if(loadCount < toLoad.length-1){
//if(walls[loadCount].data.length < otherLoadCap && walls[loadCount+1] && walls[loadCount+1].data.length < otherLoadCap){
loadBit(sMillis,reMar);
//}
}
}
}
// background
{
randomSeed(3);
var offColor = 10;
//color(3, 145, 10)
var baseColor = [57,145,79];
background(baseColor[0],baseColor[1],baseColor[2]);
for(var i = 0; i < 300; i++){

fill(baseColor[0]+random(-offColor,offColor), baseColor[1]+random(-offColor,offColor), baseColor[2]+random(-offColor,offColor));
noStroke();
var r = random(1,200);
ellipse(random(0,600),random(0,600),r,r);
}
var bg = get();
}
randomSeed(trueRandom);
textFont(monospace);
frameRate(60);

startLoading();
var loadbreak = false;

draw = function(){
    
cursor(ARROW);
switch(scene){
case 'loading':
{
cursor(WAIT);
background(0, 0, 0);
//if(frameCount/10 === round(frameCount/10)){
var sMillis = millis()-startMillis;
//println(walls[loadCount].data.length);
// !walls[loadCount].data.length|| (walls[loadCount].data.length <= otherOtherLoadCap||loadbreak)
//if(1){
//loadbreak = false;
//loadBit(sMillis,1);
//}
// if(walls[loadCount].data.length > otherOtherLoadCap){
//     loadbreak = true;
// }
loadBit(sMillis,loadRep);
textAlign(CENTER,BASELINE);
fill(255, 255, 255);
textSize(34);
text('Loading',300,150);
text(loadCount+1+'/'+(toLoad.length),300,200);
noStroke();
fill(115, 115, 115);
rect(50,300,500,50,20);
fill(255, 255, 255);
rect(50,300,(500/toLoad.length)*loadCount,50,20);
if(loadCount >= toLoad.length-1){
scene = 'game';
}
}
break;
case 'game':
//println(fr);
//println(angleDiff(p.rot,0));
framesYet += 1;
if(millis()-startMillis >= 1000){
fr = framesYet;
startMillis = millis();
framesYet = 0;
}
//smooth();
background(255, 255, 255);

pushMatrix();
trans = {
x:-p.x+300,
y:-p.y+300,
};
cam.x = lerp(cam.x,trans.x,0.4);
cam.y = lerp(cam.y,trans.y,0.4);
translate(300,300);
scale(1/zoom);
translate(-300,-300);
translate(cam.x,cam.y);
image(bg,-2500,-2500,5000,5000);
if(keys[keyBinds.attack]?.pressed||(keyBinds.attack === "click" && mouseIsPressed)){
p.attack();
}
if(!keys[keyBinds.autopilot]?.pressed){
p.dirs = [false,false,false,false];
//var dir = false;
if(keys[keyBinds.upDir]?.pressed){
p.dirs[0] = true;
}
if(keys[keyBinds.leftDir]?.pressed){
p.dirs[1] = true;
}
if(keys[keyBinds.downDir]?.pressed){
p.dirs[2] = true;
}
if(keys[keyBinds.rightDir]?.pressed){
p.dirs[3] = true;
}
p.stargDir = atan2((mouseY-trans.y)-p.y,(mouseX-trans.x)-p.x);
p.trot = p.stargDir;
p.move(p.dirs);
//println(p.rot);
}
//drawWalls();
for(var i = players.length-1; i > -1; i--){
if(players[i] !== p||keys[keyBinds.autopilot]?.pressed){
players[i].doAi();
//players[i].attack();

players[i].move(players[i].dirs);
}
players[i].doQue();
players[i].draw();
players[i].checkForKill();
}
for(var i = projs.length-1; i > -1; i--){
    //println('e');
projs[i].draw();
}
drawEffects();
for(var i = walls.length-1; i > -1; i--){
walls[i].shadow(p);
}
drawWalls();
for(var i = players.length-1; i > -1; i--){
players[i].collisions();
}
// for(var i = 0; i < 100; i++){
//     for(var q = 0; q < 100; q++){
// if(isInside(walls[9].data, walls[9].data.length, {x:i*10,y:q*10})){
// point(i*10,q*10);
// }
// }
// }

// stroke(255, 0, 0);
// strokeWeight(10);
// point(-611,138);

popMatrix();
if(keys[keyBinds.togglePowerUp]?.tapped){
//keyPID[keyBinds.togglePowerUp] = false;
p.switchPower(1);
}
if(keys[keyBinds.togglePowerDown]?.tapped){
//keyPID[keyBinds.togglePowerDown] = false;
p.switchPower(-1);
}

p.powerSelect = round(p.powerSelect);
if(((keys[keyBinds.usePower]?.tapped||(keyBinds.usePower === "click" && mouseIsPressed)))){
p.doPower(p.powerSelect);
}

for(var i = 0; i < p.powers.length; i++){

//p.powers[i].use();
pushMatrix();
translate(550,480-i*80);
if(p.powers[i].symbol){
p.powers[i].symbol(p,p.powers[i].cooldown,i);  
}else{
stroke(0, 0, 0);
strokeWeight(6);
fill(92, 92, 92);
ellipse(0,0,70,70);
}
popMatrix();
}

for(var i = 0; i < keyBinds.weapons.length; i++){

if(keys[keyBinds.weapons[i]]?.pressed){
p.switchWeapon(i);
}
fill(207, 207, 207);
stroke(64, 64, 64);
if(p.selected === i){
strokeWeight(10);
}else{
strokeWeight(6);
}
rect(i*85+3,537,85,60);
fill(0, 0, 0);
textAlign(CENTER,BASELINE);
textSize(10);
text(i+1,i*85-29,545,85,60);
if(p.weapons[i]){
fill(0, 0, 0);
textAlign(CENTER,BASELINE);
textSize(10);
pushMatrix();
if(getWeaponStats(p.weapons[i]).textDis){
translate(getWeaponStats(p.weapons[i]).textDis.x,getWeaponStats(p.weapons[i]).textDis.y);
}
text(p.weapons[i],i*85,575,85,60);
popMatrix();
pushMatrix();
if(getWeaponStats(p.weapons[i]).hbDis.scale){
translate(i*85+getWeaponStats(p.weapons[i]).hbDis.x,getWeaponStats(p.weapons[i]).hbDis.y);
scale(getWeaponStats(p.weapons[i]).hbDis.scale);
translate(-(i*85+getWeaponStats(p.weapons[i]).hbDis.x),-getWeaponStats(p.weapons[i]).hbDis.y);
}
drawWeapon(p.weapons[i],{
x:i*85+getWeaponStats(p.weapons[i]).hbDis.x,
y:getWeaponStats(p.weapons[i]).hbDis.y,
rot:getWeaponStats(p.weapons[i]).hbDis.rot,
charge:0,
},100,true);
popMatrix();

fill(0, 0, 0,100);
stroke(64, 64, 64);
var down = 60-(60/getWeaponStats(p.weapons[i]).cooldown)*p.cooldown;
if(down < 0){
down = 0;
}
rect(i*85+3,537,85,down);

}
}

fill(255, 0, 0);
textSize(20);
textAlign(LEFT,BASELINE);
text('Framerate: '+fr,10,20);

clicked = false;
break;
}
manageKeys();
};
//draw = DeKhan.loopDetect(draw);  
function mouseClicked(){
    clicked = true;
    println('e');
}

//var r = random();

    
			</script>
	
	<script src="https://cdn.jsdelivr.net/gh/vExcess/library_files@main/runPJS_onKA.js"></script>
	<script>
	</script>
</body>

</html>
